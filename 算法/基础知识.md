## 数据结构基础套路
### 概述
1. 好算法的本质？
* 正确性。算法应该能够正确地解决求解问题。
* 可读性。算法应该具备良好的可读性，以帮助人们理解。
* 健壮性。输入非法数据时，算法能够适当地做出反应或者进行处理，而不会产生莫名奇妙的输出结果。
* 低的时间复杂度和低的空间复杂度。

2. 算法效率的度量？
* 时间复杂度：事前预估算法时间开销 `T(n)` 与问题规模 `n` 的关系。
    - 加法规则：`T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))`
    - 乘法规则：`T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))`
    - 顺序执行的代码只会影响常数项，可以忽略；只需要找循环中的一个基本操作，分析它的执行次数与n的关系即可；如果有多层嵌套循环，只需要关注最深层循环循环了几次。
    - 时间复杂度有最好时间复杂度、最坏时间复杂度、平均时间复杂度。主要关注最坏和平均时间复杂度。
* 空间复杂度：空间开销（内存开销）与问题规模`n`之间的关系。
    - 加法规则：`T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))`
    - 空间复杂度主要是与 `数组的大小` 和 `递归调用的深度` 有关。

### 输入输出总结 (原文)[https://ac.nowcoder.com/acm/contest/5657#question]
* streamstring 类对象的用法[https://blog.csdn.net/sinat_28305511/article/details/131237559] 1.字符串转换为其他数据类型 2.其他数据类型转换为字符串 3.配合 std::getline() 分割字符串 4.拼接字符串  5.通过 ss.str("") 清空 stringstream 对象
* std::getline() 用于从流(输入流，文件流，字符串流)中读取数据。其能够指定定界符号。
```C++
#include <iostream>
#include <sstream>
#include <string>
 
int main() 
{
    std::string data = "one,two,three,four";
    std::stringstream iss(data);
    std::cout << iss.str() << std::endl;
    std::string token;
 
    while (std::getline(iss, token, ',')) 
    {
        std::cout << token << std::endl;
    }
    std::cout << iss.str() << std::endl;
 
    return 0;
}

// 输出
// one,two,three,four
// one
// two
// three
// four
// one,two,three,four
```

### 数组
数组是存放在连续内存空间上的相同类型数据的集合, 可以通过下标索引的方式获取得到下标对应的数据；因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址；C++中二维数组是连续分布的。

#### 二分查找
1. 使用二分法的前提条件：1）数组有序 2）数组中无重复元素
2. 二分法的实现的注意事项：1）定义区间 [left, right]（左闭右闭） 2）循环条件(left<=right) 3）middle=left + (right-left)/2, 防止 left+right 溢出 3）通过判断 nums[middle] 与 target 的关系来决定更新 right, 还是 left, 还是直接返回 middle。4）注意更新的是 middle-1 和 middle+1, 而不是 middle。
3. 时间复杂度 `O(logn)`, 空间复杂度 O(1)。

#### 删除数组中元素 val
1. 整体思路就是, 将所有不等于 val 的值都移到数组前面, 记录非 val 值的个数, 然后直接 resize。
2. 这个题可以使用双指针的方法：1）快指针：遍历新元素，保存新元素的索引 2）慢指针：更新数组的下标的位置(这个起始也就代表了元素的个数)。
3. 快指针一直向前遍历所有元素，如果快指针指向的元素不等于 val, 就更新到慢指针指向的位置，慢指针+1；如果快指针指向的元素等于 val，不更新到慢指针指向的元素。

#### 滑动窗口
滑动窗口是不断地调整子序列的起始位置和终止位置，从而得到我们想要的结果。
1. 滑动窗口本该是用两个 for 循环来做(一个起始位置，一个终止位置，时间复杂度为 O(n^2))
2. 而利用双指针法，利用一个 for 来遍历起始/终止位置, 再用一个指针来自动调节窗口的终止/起始位置。
3. 指针如何移动呢？主要考虑题目条件, 连续累加和超过？（移动一个元素）, 有些题目也有可能移动到快指针的位置
4. 注意这里的`双指针要都包含边界`, 所以得出个数的时候要 终止位置索引-起始位置索引+1。

#### 螺旋矩阵
这道题目，主要核心点就在于以下几点：1）确定需要循环的次数 n/2，n 为奇数的时候需要手动填充中间的值 2）每次循环开始的位置 3）每次循环开始的时候都确定 i 和 j
4）四个循环公用一套 i 和 j 5）填充的区间都是左闭右开，这样四个循环都是对称的。

### 链表
1. 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域，最后一个节点的指针域指向 `null`。链表分为单链表、双链表、循环链表。C++ 中链表的定义方式如下：
```C++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(nullptr) {};  // 节点的构造函数
};
```
2. C++中删除链表中某个节点：`A->B->C`(删除其中的 B 节点), 保存下 A 指向的下一个节点, 让 A 指向 C, 释放 A 指向的下一个节点。
3. C++中增添链表中某个节点：`A->C`(A->C 中增添 B), 保存 A 指向的下一个节点, 让 A 指向 B, 让 B 指向保存的 A 指向的下一个节点(C)。

#### 虚拟头节点
通常可以通过增加虚拟头节点的操作来使得对链表的操作进行统一。链表的一大问题就是操作当前节点必须要找前一个节点才能操作，因为头节点没有前一个节点了。
1. 添加和删除虚拟头节点的操作可以使得操作链表(插入，删除，索引)变得简单
```C++
ListNode* dummyHead = new ListNode(0);  // 设置虚拟头节点
dummyHead->next = head;  // 将虚拟头节点指向 head

// 返回新的头节点
head = dummyHead->next;
delete dummyHead;
return head;
```
#### 反转链表
1. 反转头节点不需要使用虚拟头节点。
2. 使用 `双指针的方法`。fast 指针初始化为头节点, slow 指针初始化为 nullptr。循环逻辑就是, 用 tmp 临时保存 fast->next, 然后 cur->next 指向 slow，更新 pre = cur, cur=tmp, 直到 cur == nullptr, 此时返回 链表头节点 pre。

#### 两两交换链表中的节点
1. 需要使用虚拟头节点。
2. 做链表的题目, 一定要把画图，用一组数据进行模型, 把每个步骤清楚的标注出来, 依据标注出来的结果来写代码。
3. 注意边界条件, 根据到结尾的第几个节点终止来确定循环的边界条件。本题是 `while(cur->next != nullptr && cur->next->next != nullptr)`。

#### 删除链表的倒数第 N 个节点
1. 需要使用虚拟头节点。
2. 使用双指针的逻辑, 快指针和慢指针都初始指向虚拟头节点。快指针先移动 N+1 步, 然后快慢指针一起移动, 直到快指针为 nullptr, 此时参数慢指针的next指向的节点。

#### 求链表长度的方法
1. 求链表长度时, 主要循环终止条件, 如下
```C++
int lenA = 0;
while(curA!=NULL){
    ++lenA;
    curA = curA->next;
}
```
2. 对于两个链表或者两个数组, 不能确定谁的元素多，谁的元素少时, 直接先判断长度, 然后用 `std::sawp` 进行交换, 保证想要的那个是元素多的。
```C++
curA = headA;
curB = headB;
// 让curA为最长链表的头，lenA为其长度
if (lenB > lenA) {
    swap (lenA, lenB);
    swap (curA, curB);
}
```

#### 判断链表是否有环, 并找到环的入口
1. 判断入口是否有环，使用快慢指针的方法, 这道题目不用虚拟头节点。
2. 快慢指针都从头指针出发，快指针每次移动2步，慢指针每次移动1步, 如果快指针等于慢指针, 则说明有环, 如果快指针检测到有 nullptr, 那就是无环。
3. 环的入口需要依据一个数学公式，从头节点到环的入口和从相遇点到环的入口，所走路程是相同的（前提仍然是 fast 每次走两步，slow 每次走一步依据这个公式来做）。

### 哈希表
哈希表是根据关键码的值而直接进行访问的数据结构，哈希表用来快速判断一个元素是否出现在集合中。哈希函数，通过hashCode把名字转化为数值，一般hashCode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。可以使用拉链法和线性探测法来解决哈希碰撞问题：
    * 拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间, 哈希表大小一定要合适，要映射尽可能的均匀。
    * 使用线性探测法，一定要保证 tableSize 大于 dataSize, 我们需要依靠哈希表中的空位来解决碰撞问题。
| 集合 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
|:----:|:-------:|:--------:|:---------------:|:------------:|:-------:|:--------:|
| std::set | 红黑树 | 有序 | 否 | 否 | O(log n) | O(log n) |
| std::multiset | 红黑树 | 有序 | 是 | 否 | O(log n) | O(log n)|
| std::unordered_set | 哈希表 | 无序 | 否 | 否 | O(1) | O(1) |

|映射	|底层实现|	是否有序|	数值是否可以重复|	能否更改数值|	查询效率|	增删效率|
|:----:|:-------:|:--------:|:---------------:|:------------:|:-------:|:--------:|
|std::map|	红黑树|	key有序|	key不可重复	|key不可修改	|O(logn)	|O(logn)|
|std::multimap|	红黑树|	key有序|	key可重复|	key不可修改|	O(log n)	|O(log n)|
|std::unordered_map| 哈希表|	key无序|	key不可重复|	key不可修改|	O(1)|	O(1)|

#### 有效的字符异位词
* 对于有限的、连续的、跨度小的哈希值，比如 26 个英文字母，可以直接映射到一个数组中，'a'映射到下标为0，'z'映射到下标为25；
* 这道题目是 3 个循环，第一个循环先统计其中一个字符串各个字符出现的次数并加1，第二个循环统计另一个字符串各个字符出现的次数并减1，最后一个循环用来判断各个元素是否为0
* 为什么遇到哈希问题不直接使用 unordered_set 系列容器呢，是因为 unordered_set 系列容器不仅空间占比大，而且把数值映射到key上都要做 hasd 计算的，计算速度慢。

#### 两个数组的交集
* 求两个数组的交集，其实需要两个 unordered_set, 第一是将其中一个数组去重，遍历另一个数组的元素，若有发现其在第一个 unordered_set 中, 则将其元素加入到另一个 unordered_set 中。
* set 系列用于哈希值少，比较分撒，跨度很大的场景，也就是数组不适合的场景，都用 set 来做。
* 这里的有一些语法需要注意：set 与 vector 之间的转换, map 与 vector 之间的转换。
```C++
// set 与 vector 之间的互相转换
#include <vector>
#include <unordered_set>

int main() {
    std::vector<int> vec {1, 2, 3, 4};
    std::unordered_set<int> set(vec.begin(), vec.end());
    vec = std::vector<int>(set.begin(), set.end());
}
```

```C++
// map 转换为 vector
#include <string>
#include <map>
#include <vector>
#include <algorithm>

int main()
{
    std::map<std::string, int> map;
    std::vector<int> vec;

    map["one"] = 1;
    map["two"] = 2;
    map["three"] = 3;
    map["four"] = 4;
    map["five"] = 5;

    // 用于对范围内的元素进行变换，并将结果存储到另一个范围。
    std::transform( 
        map.begin(), 
        map.end(),
        std::back_inserter(vec),        // 需要使用back_inserter，它会自动为vector分配空间
        [](auto &kv){ return kv.first;} // 返回输入迭代器的key，需要c++14
    );
}

// 注意这种写法, 上面的 back_inserter 是未分配空间，能够自动扩充, 接下来的是分配了空间
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec1 {1, 2, 3, 4, 5};
    std::vector<int> vec2 {1, 2, 3, 4, 5};
    std::vector<int> result(vec1.size());

    std::transform(vec1.begin(), vec1.end(), vec2.begin(), result.begin(), [](int x, int y) { return x + y; });

    for (int i : result) {
        std::cout << i << " ";
    }

    return 0;
}
```

#### 快乐数
* 要注意审题，题目中说了，如果其是快乐数，最后的各个位平方之和为 1，否则会无限循环。注意这个无限循环，其意味着如果不是快乐数，各个位平方之和的结果会循环出现。
* 这道题目就只能用 set 系列来做，因为不满足有限、尽可能连续的数组应用规则。
* 给一个正整数，取各个位上的数字的方法：
```C++
// 这里加了对负数挑选其各个位的方法，从低位到高位，就是很好拿出来呢
std::vector<int> getNum(int n)
{
    // 这里得到的结果是从低位到高位
    std::vector<int> result;
    bool isNegative = n < 0;
    n = std::abs(n);
    
    while(n){
        result.push_back(n % 10);
        n /= 10;
    }

    // 如果是负数，处理特殊情况
    if (isNegative && !result.empty()) {
        result.back() *= -1; // 把最后一位变成负数
    }

    return result;
}
```

#### 两数之和
* 首先应该想到的是，用一个循环遍历每个元素，能够知道其中一个数是多少，但是需要查找数组中是否有另一个数, 所以想到了用哈希表。
* 但是不能直接把数组转换为 set，因为这样可能会有重复元素，未说明数组中元素不能重复。
* 所以可以先逐个遍历，将遍历过的数字加入到集合中，即使有重复也不怕，因为是选两个元素，当前遍历到的就是第一个。
* 所以使用 std::unordered_map 即可，注意这里需要 key 存储数组值，value 存储索引下标（因为要找到这两个数的索引下标）。

#### 三数之和
* 通常来说，返回数组元素的内容的组合，而不是数组下标的组合，一般都是需要先排序的，然后再来做。
* 这道题目让返回的是元素内容，我们想到用双指针的方法。
* 首先对数据进行排序(从小到大)，然后利用一个 for 循环从左向右遍历，确定一个元素i（这个元素一定出现在数组中）
* left = i+1, right=size()-1, 如果 A[i] + A[left] + A[right] < target, 那就 left++; 如果 > , 就 right--; 不断重复循环，直到 left >= right
* 以上是遍历所有的组合，但是返回的结果要去重。对于 i 这个最小值的去重，`if(i>0 && nums[i]==nums[i-1]) continue;`。对于 left 和 right 的去重，是在每次添加完元素之后，`while (right > left && nums[right] == nums[right - 1]) right--;` 和 ` while (right > left && nums[left] == nums[left + 1]) left++;`;
* 还有一种利用 set 容器来去重的操作，代码如下所示
```C++
/*
    set::set 是基于红黑树（或其他平衡二叉搜索树）实现的有序容器。
    它使用元素类型的 < 运算符（或者自定义的比较函数）来维护元素的有序性和唯一性。
    因此，只要元素类型支持 < 运算符，std::set 就可以直接使用。
    std::vector<> 和 std::array<> 均重载了 operator< 就是逐个比较其中元素的大小

    是基于哈希表实现的无序容器。它依赖于元素类型的哈希函数和相等比较函数来确保元素的唯一性和查找的高效性。
    标准库中并没有为 std::vector<int> 提供默认的哈希函数和相等比较函数，因此我们需要自己提供这些函数。
*/
#include <iostream>
#include <vector>
#include <array>
#include <algorithm>
#include <set>
#include <unordered_set>

int main() {
    // 示例数据
    std::vector<std::array<int, 3>> vec = {
        {1, 2, 3},
        {4, 5, 6},
        {1, 2, 3}, // 重复元素
        {3, 2, 1}, // 重复元素
        {7, 8, 9},
        {4, 4, 6}  // 重复元素
    };

    // 使用 std::set 去重
    std::set<std::array<int, 3>> s(vec.begin(), vec.end());
    vec.assign(s.begin(), s.end());

    // 输出去重后的结果
    for (const auto& arr : vec) {
        std::cout << "{" << arr[0] << ", " << arr[1] << ", " << arr[2] << "}\n";
    }

    return 0;
}
```
* 两数之和那道题目，要求返回的是索引，所以不能直接使用这种双指针的方法，不然第一步一排序，就直接乱套了。

#### 四数之和
* 这道题目其实和三数之和是同一个道理，本来应该是 O(n^4) 的时间复杂度，通过双指针的方法降低成为了 O(n^3)
* 三数之和是先利用一个 for 循环确定一个最小的值，而四数之和就是先利用两个 for 循环来确定两个最小的值，然后再利用 left 和 right 进行一个遍历
* 注意这里也有去重的操作，与三数之和是一样的道理。i 是去重后的 i, k=i+1 开始，在对 k 去重。然后 left = k+1, right = size()-1;
* 总结一下的话，从三数之和和四数之和来看，每个索引都要去重，只不过 left 和 right 是在结果加入完之后再去重。

#### 四数相加
* 注意题目问的是有多少个？我们只需要统计次数就可以了。
* 将四个数组分成两组，A 和 B 一组，先计算这两个数组能够相加出来的和，并存入 map 中, key 是相加的和, value 是出现的次数。
* 再遍历 B 和 C，寻找其相加的和，如果能在 上一个 map 中找到相反数，就加一次 value 的值。
* 这样两两归类，就将时间复杂度从 O(n^4) 降低到了 O(n^2)。

### 字符串
#### 字符串反转
* 对于字符串反转、数组反转，其实写法都是一样的，都是用双指针的方法，`left=0, right=size()-1`, 循环条件是 `while(left<right)`, 注意交换写法，直接使用 `std::swap()`
* 对于链表的反转，也是利用双指针的方法，不过是直接改变指针的指向。
* 但是要注意的是, 也要善于使用库函数, std::reverse 反转，能够方便地实现某个区间内的反转。

#### 替换数字
* 其实这道题目是一个向数组或者字符串中插入多个元素的问题，是使用双指针的方法。
* 先用一个指针指向扩容前的最后一个元素，再用一个指针指向扩容后的最后一个元素，指向扩容后的元素的指针不到起始位置的时候，不停止。
* 先判断指向扩容前的指针指向的索引或者元素内容，然后向扩容后的位置插入特定的元素。
* 这道题目与删除数组/串中指定的值（多次删除）有很多相似之处，那个也是双指针的做法。

#### 反转字符串里的单词
* 实现 `"  hello world!  " -> "world! hello"`, 去除字符串中多余的空格, 利用双指针的方法，去除字符串中的某个元素（慢指针指向空格时候, 快指针必须指向字符串才能往后更新）。
* 然后将整个字符串反转，直接使用库函数即可；最后再将其中的每个单词进行反转(一次for遍历，利用一个变量记录上次单词开始的位置)
* 注意这种先整体大反转，再局部分块小反转的方法，是非常有用的。
* 右循环移动字符串/数组，将字符串/数组整体向右循环移动 n 位。其实整体思路就是将其分成两个部分，后n位和起始到后n位之前的部分。先将整个字符串颠倒，然后再将这两个位置分别颠倒。

#### KMP 算法
* KMP的经典思想就是：当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。
* 其实除了字符串，数组也是一样的。抽象来说，就是对一个主串，寻找第一次出现模式串的位置。
* next 数组就是一个前缀表，前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。
* 时间复杂度 O(n+m), 空间复杂度 O(m)[因为需要保存needle的前缀表]

```C++
void getNext(std::vector<int>& next, const std::string& s){
    int j=-1;
    next[0] = j;

    for(int i=1; i<s.size(); ++i)
    {
        while(j>=0 && s[j+1]!=s[i])
        {
            j=next[j];
        }

        if(s[j+1]==s[i])  // 只有相等的时候才 ++j
        {
            ++j;
        }

        next[i]=j;  // 要保证每个 next 都有值
    }
}

int getIdx(const std::string& str, const std::string& needle)
{
    if(needle.size()==0) return 0;  // 搜索空字符串时, 返回 0, 特殊规定

    std::vector<int> next(needle.size());  // 核心是 next 数组, j 是最长相等前后缀的值, next[j] 是前 j 个字符中最长相等前后缀的值
    getNext(next, needle);

    int j=-1;  // 因为下面比较了 needle [j+1] 和 str[i], 所以 j 是从 -1 开始的
    for(int i=0; i<str.size(); ++i)
    {
        while(j>=0 && needle[j+1]!=str[i])
        {
            j=next[j];
        }

        // j 在这里也是统计着最长相等前后缀的值 
        if (needle[j + 1] == str[i]) {  // 只有相等才 ++
            ++j;
        }

        if(j==needle.size()-1)
        {
            return i-j;
        }
    }

    return -1;
}
```

#### 重复的子字符串
* 这道题目其实没有什么技巧，只是能不能想到这种方法。
* 将两个子串s拼接到一起(t=s+s)，然后删除掉t的第一个元素和删除掉最后一个元素。在剩余串中寻找是否还能出现 s，若能出现则是由重复的串构成的。
* 这里的 KMP 算法就直接使用 `find` 函数就可以了。
* 要是数组的话，可以先转为字符串在进行操作，或者直接使用 KMP 算法进行寻找。

### 栈与队列
* 栈是先进后出，C++中是 `std::stack<>`, 队列是先进先出，C++ 中是 `std::queue<>`。栈和队列在 C++ 中都是容器适配器，其底层容器是 `std::queue<>`, `std::vector<>` 或 `std::list<>` (其实 C++ 中的栈和队列要求的是底层容器能够提供那些函数，如果自定义的类包含这些函数，那也可以使用自定义的)。
* 栈里面的元素在内存中是连续分布的么？
    - 陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。
    - 陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。

#### 用栈实现队列
* 要用两个栈来实现队列，一个输入栈，一个输出栈。输入栈负责队列的 push 操作，输出栈负责队列的 pop 操作。
* 在队列 push 的时候，将数据都放入到输入栈就行；在队列 pop 的时候，如果输出栈为空，就把输入栈数据全部导入进输出栈，再从输出栈弹出数据。
* 如果输入栈和输出栈都为空的时候，队列就为空。

#### 用单向队列实现栈
* 使用两个单向队列，一个做为输入队列，一个做为输出队列，其实是没有作用的，因为并不会颠倒元素顺序。
* 其实只需要使用一个单向队列就能实现栈，在栈 push 的时候，直接将元素 push 进队列就行; 在栈 pop 的时候, 将除了最后一个元素全都 pop 出去，然后依次加入到队列末尾。此时再 pop，就得到了最后加入的元素。
* 当单向队列为空的时候，栈就空了。

#### 括号匹配(栈)
* 由于栈的结构，使其非常适合做`对称匹配`的问题。
* 依次编列输入的括号字符串，如果当前的字符是`(`，`[`等左括号，就将其需要匹配的右括号`)`, `]`加入栈中；如果当前字符是右括号`]`，`)`, 就判断栈是否为空，如果为空就匹配失败，如果不为空，但是栈顶元素不等于当前字符也匹配失败。遍历完所有字符后，如果栈不为空，仍然匹配失败。

#### 删除字符串中重复的元素(栈)
* 这个也是匹配问题，通过遍历当前元素来前一个元素是否与当前遍历的元素相同。
* 这里如果用栈做为中间存储的话，最后要记得颠倒下字符元素，最简洁的方法是直接用存储字符串的结果来当作栈使用。

#### 逆波兰表达式(栈)
* 逆波兰表达式是一种后缀表达式(运算符写在后面), 比如平时正常的中缀表达式是 (1+2)*(3+4) 变成后缀表达式后为 `12+34+*`, 逆波兰表达式其实是用后序遍历的方式把二叉树序列化。
* 逆波兰表达式的优点是，去掉括号表达式无歧义，使用用栈操作运算（遇到数字则入栈，遇到运算符去除栈顶两个元素进行计算，并将结果压入栈中）。
* 逆波兰表达式求值的整体思路是：遇到数字则入栈; 遇到运算符去除栈顶两个元素进行计算，并将结果压入栈中; 最终表达式是值就是栈里的最后一个元素。

#### 滑动窗口最大值(单调队列)
* 其实就是要求能够找到最大的元素，而且还能够删除指定的元素。
* 如果使用优先队列(大顶堆) `priority_queue`，能够每次找到最大的元素，但是并不能删除指定的元素。
* 所以这里可以使用自建的单调队列，也可以使用 `multiset`，这个是满足这个性质的，而且元素能够重复。
* 注意这里实现滑动窗口的代码逻辑。逐一遍历数组中的元素，当加入前 k-1 个时候，只有向 `multiset` 中插入的操作；当插入完前k个元素后，以后每次都要将 set 中的最大值保存到数组中（利用 `rbegin()`, 因为默认是从小到达排序）, 从第 k+1 个元素开始，就每次都是删除一个指定元素(i-k)，添加一个指定元素。
* 这里也给我们提了个醒，对于变化的元素进行排序的时候，可以使用红黑树的 `set` 来帮助我们。

#### 前 k 个高频元素(优先队列)
* 这里主要分成三个步骤，先用 map 统计每个元素出现的频率；然后依据频率进行排序；最后找出前 K 个最高频的元素。
* 因为 C++ 中的 map 通常只能依据 key 的值来进行排序，所以这里利用优先队列(小顶堆)来进行排序，即队列元素小于k的时候，就一直将map元素往里扔。当时队列元素等于k的时候，每次压入元素前，先把最小的给剔除。
* 最后将优先队列中的k个元素逐个pop()出去，然后依序加入到 vector 中，就是从大到小的结果。
```C++
// 小顶堆
class mycomparison {
public:
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};

// 对频率排序
// 定义一个小顶堆，大小为k
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
```
* 其实还有其他方法实现对 map 中元素的排序；首先仍然是先使用 map 统计各个词出现的频率；然后定义一个 set, 自定义排序顺序，将 map 中的元素都加入到 set 中。

#### 单调栈
* 单调栈通常用于一维数组，要寻找任一元素的右边或者左边第一个比自己大或者小的元素的位置，时间复杂度为 `O(n)`, 单调栈的本质也是空间换时间。
* 单调栈中存储的是数组下标，在从头向后遍历数组的时候，如果要找到每个元素最右侧第一个大于自己的数组下标，就应该让单调栈从栈头到栈底是单调递增的。
* 如果要找每个最右侧第一个小于自己的数组下标，就应该让单调栈从栈头到栈底是单调递减的(同理，如果要是最左侧，就是换个方向，从尾向头遍历)。
* 需要注意的事项：
    - 栈首先要将第一个元素压入栈中，因为接下来的逻辑是一直要与栈头元素所代表的值判断。
    - 每遍历到一个元素，就要将这个元素在数组中代表的值与栈头的元素所代表的值进行对比(基本上就两种操作，直接压入栈或者先弹出一些元素，再直接压入栈)。
    - 一定要注意默认的结果是多少，数组就初始化为多少。

```C++
// 版本一
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        // 递增栈
        stack<int> st;
        vector<int> result(T.size(), 0);
        st.push(0);
        for (int i = 1; i < T.size(); i++) {
            if (T[i] < T[st.top()]) {                       // 情况一
                st.push(i);
            } else if (T[i] == T[st.top()]) {               // 情况二
                st.push(i);
            } else {
                while (!st.empty() && T[i] > T[st.top()]) { // 情况三
                    result[st.top()] = i - st.top();
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

* 下一个更大元素(寻找部分元素的下一个最大元素)
    - 这道题目中注意，一说到无重复元素就要想到，1）可以进行先排序，再做其他运算 2）可以将 value 做为 map 的key, 而数组索引做为 map 的值。
    - 当要知道数组 nums2 中的元素是否在 nums1 中出现过时，就要想到要用 set/map 进行映射, set 能够知道是否出现过，map 还能知道具体出现在 nums1 中的哪里(要保证 nums1 是不重复的，利用 value-index 来创建 map)。
    - 这道题目也是有些默认值的，题目中说了，默认值填写为 -1 就可以了，所以初始化 result 数组时候，使用 -1 来填充就可以了。

* 循环下一个最大元素
    - 这道题目最简单的方法，其实是将数组num重复一遍，拼成一个新的数组，然后再利用单调栈就可以解决了。
    - 另一种方法需要好好掌握，其实也就是循环遍历的方法。
    ```C++
    for(int i=0; i<2*nums.size(); ++i)  // for 循环控制循环的次数
    {   // id 依次取值为 0, 1, ..., nums.size()-1, 0, 1, ... , nums.size()-1
        int idx = i % nums.size();  // 接下来就是一直使用 idx 了
    }
    ```

* 接雨水
    - 这道题目有两种计算方法，逐行计算和逐列计算。逐列计算是动态规划+直接计算的方法，逐行计算是单调栈的方法。
    - 对于逐列计算，需要记录每个柱子左侧柱子(包含当前柱子)的最高高度和右侧柱子(包含当前柱子)的最高高度。遍历每个柱子，`当前列雨水面积=(min(左边柱子的最高高度, 右边柱子的最高高度)-当前柱子的最高高度)*1`。
    - 分别使用 maxRight 和 maxLeft 来动态规划记录最左侧和最右侧柱子的最大高度。`maxLeft[i]` 表示包含柱子 i 左侧柱子的最大高度，动规公式为 `maxLeft[i]=std::max(height[i], maxLeft[i-1])`。
    ```C++
    class Solution {
    public:
        int trap(vector<int>& height) {
            if (height.size() <= 2) return 0;

            // 动规数组
            vector<int> maxLeft(height.size(), 0);
            vector<int> maxRight(height.size(), 0);
            int size = maxRight.size();

            // 记录每个柱子左边柱子最大高度
            maxLeft[0] = height[0];
            for (int i = 1; i < size; i++) {
                maxLeft[i] = max(height[i], maxLeft[i - 1]);
            }
            // 记录每个柱子右边柱子最大高度
            maxRight[size - 1] = height[size - 1];
            for (int i = size - 2; i >= 0; i--) {
                maxRight[i] = max(height[i], maxRight[i + 1]);
            }

            // 求和, 一个柱子一个柱子的遍历，从头遍历到结尾
            int sum = 0;
            for (int i = 0; i < size; i++) {
                int count = min(maxLeft[i], maxRight[i]) - height[i];
                if (count > 0) sum += count;  // 这里要加个判断，并不是每个柱子都能有积水的
            }

            return sum;
        }
    };
    ```
    - 对于逐行计算，确定是从左往右遍历(因为要找每个元素最右侧的元素), 栈头到栈尾是递增的（要找大于的）。
    - 注意一点是，当前遍历的元素大于栈顶元素，则出现了凹槽，其中一个边是栈顶的里面的哪一个元素，第二个边就是当前的元素。
    - 可知雨水的高度为 `min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度`, 雨水的宽度为 `凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度）`, 雨水面积为 `h*w`。
    - 注意这里两边的是如何处理的。
    ```C++
    class Solution {
    public:
        int trap(vector<int>& height) {
            if (height.size() <= 2) return 0; // 可以不加

            stack<int> st;
            st.push(0);
            int sum = 0;
            for (int i = 1; i < height.size(); i++) {
                while (!st.empty() && height[i] > height[st.top()]) {
                    int mid = st.top();
                    st.pop();
                    if (!st.empty()) {
                        int h = min(height[st.top()], height[i]) - height[mid];
                        int w = i - st.top() - 1;
                        sum += h * w;
                    }
                }
                st.push(i);
            }
            return sum;
        }
    };
    ```

* 柱状图中的最大矩形面积
    - 本题是寻找栈顶和栈顶的下一个元素以及要入栈的三个元素组成我们要求最大面积的高度和宽度。
    - 要注意边界条件，1）元素个数不够的时候 2）元素均为升序的时候 3）元素均为降序的时候
    ```C++
    class Solution {
    public:
        int largestRectangleArea(vector<int>& heights) {
            stack<int> st;
            heights.insert(heights.begin(), 0); // 数组头部加入元素0(防止为单减的时候得不到 left)
            heights.push_back(0); // 数组尾部加入元素0(防止为单增的时候，不进入while)
            st.push(0);
            int result = 0;
            for (int i = 1; i < heights.size(); i++) {
                while (heights[i] < heights[st.top()]) {
                    int mid = st.top();
                    st.pop();
                    int w = i - st.top() - 1;
                    int h = heights[mid];
                    result = max(result, w * h);
                }
                st.push(i);
            }
            return result;
        }
    };
    ```

### 二叉树
* 常用的二叉树的两种主要形式：满二叉树和完全二叉树。满二叉树：深度为k(只有一个节点的二叉树，深度为1), 有 $2^k-1$ 个节点的二叉树(第 k 层的节点个数为 $2^{k-1}$)；完全二叉树：在完全二叉树中，除了最底层的节点可能没有填满以外，其余每层的节点数都达到最大值，其最下面一层的节点都集中在该层最左边的若干位置(当h不是最后一个层时，这层节点数为 $2^{k-1}$, 否则为 1~$2^{k-1}$)。
* 有值得二叉树常用两种形式：二叉排序树和平衡二叉树。二叉排序树：若左子树不为空，则左子树所有节点的值均小于根节点的值；若右子树不为空，则右子树所有节点的值均大于根节点的值; 它的左、右子树也分别是二叉排序树；平衡二叉树：左右两个子树的高度差的绝对值不会超过 1, 并且左右两个子树都是平衡二叉树。
* 二叉树的存储方式：链式存储和顺序存储。链式存储就和链表类似，顺序存储就是用数组存储。
```C++
// 链式存储
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// 数组存储
// 根节点位于数组中下标为0的位置。父节点的数组下标时 i, 左孩子下标就是 2*i+1, 右孩子就是 2*i+2。
```

#### 二叉树的深度遍历(递归)
* 二叉树主要有深度优先遍历和广度优先遍历两种类型。其中深度优先遍历是先往深走，遇到叶子节点再往回走；广度优先遍历时一层一层的去遍历。深度优先遍历包括：前序遍历（递归法，迭代法），中序遍历（递归法，迭代法），后序遍历（递归法，迭代法）；广度优先遍历：层次遍历（迭代法）。
* 在写递归函数的时候，要注意三个点：函数参数和返回值（每层都返回什么）, 终止条件(不可能无限制递归下去), 单层递归的逻辑。
```C++
// 前序遍历
class Solution {
public:
    // 往深层里遍历，每遇到一个不为 nullptr 的，先将当前值加入到遍历结果中，然后再遍历其左侧和右侧的节点。
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};

// 中序遍历，先一股脑的向左侧扎下去（先左侧遍历到nullptr）
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}

// 后续遍历
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

#### 二叉树的深度遍历(迭代)
* 对于迭代的方法，其实就是用栈模拟函数调用的过程(参考着递归的过程来写非迭代的方法)。前序遍历如下：
    - 先让头节点入栈。
    - 然后开始迭代，每次都是取出栈顶元素(这个是进入这个为头节点的函数), 然后先把右边的加进去(后递归这个)，再把左边的加进去。
    ```C++
    class Solution {
    public:
        vector<int> preorderTraversal(TreeNode* root) {
            stack<TreeNode*> st;
            vector<int> result;
            if (root == NULL) return result;
            st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();                       // 中
                st.pop();
                result.push_back(node->val);
                if (node->right) st.push(node->right);           // 右（空节点不入栈）
                if (node->left) st.push(node->left);             // 左（空节点不入栈）
            }
            return result;
        }
    };
    ````
* 中序遍历的方法其实也不难，就是要对比递归来做：
    - 总体思路就是直接进入新的节点，就一直往左遍历，直到为 nullptr;
    - 当为 nullptr 时，退一个，即取出栈顶元素，然后将其遍历，将其右侧加入到栈中
    ```C++
    class Solution {
    public:
        vector<int> inorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            TreeNode* cur = root;
            while (cur != NULL || !st.empty()) {
                if (cur != NULL) {  // 不为 nullptr，就往左遍历
                    st.push(cur);
                    cur = cur->left;                // 左
                } else {
                    cur = st.top(); // 从栈里弹出的数据, 其实这个相当于是递归中回退了一次
                    st.pop();
                    result.push_back(cur->val);     // 中
                    cur = cur->right;               // 右
                }
            }
            return result;
        }
    };
    ```
* 后序遍历比中序遍历还要更多考虑一些，因为遍历完左的，回退一步，并不弹出，而是转头遍历右侧的，所以需要 prev 来记录下（prev 记录的上一个已经被遍历了右子树的节点）。最后 cur = nullptr 是已经知道了没有左侧的节点了。
    ```C++
    class Solution {
    public:
        vector<int> postorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            TreeNode* cur = root;
            TreeNode* prev = nullptr;
            while (cur != NULL || !st.empty()) {
                if (cur != NULL) {  // 不为 nullptr，就往左遍历
                    st.push(cur);
                    cur = cur->left;                // 左
                } else {
                    cur = st.top(); // 从栈里弹出的数据, 其实这个相当于是递归中回退了一次
                    if(cur->right && cur->right!=prev){  // 右节点不为 nullptr, 且右节点未被访问过
                        cur = cur->right;
                    }else{
                        st.pop();
                        result.push_back(cur->val);     // 中
                        prev = cur;
                        cur = nullptr;  // 因为 cur 的 left 肯定是没有了，right 进到 else 里也是没了或者被访问过
                    }
                }
            }
            return result;
        }
    };
    ```

#### 二叉树的广度优先遍历(层序)
* 二叉树的层序遍历就是广度优先遍历的一种特殊形式，一层一层的遍历，这一层连接到下一层的桥梁就是节点的左右节点, 需要注意的一点就是，每层的数量是固定的，不要单纯使用变化的 `que.size()`。
```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

#### 翻转二叉树
* 其实就是考察二叉树的遍历，只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果, 可以直接使用前向遍历递归法, 也是简单的。
```C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        // 就是注意是接下来的反转左右，其实是反转原始的右左子树
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
};
```

#### 对称二叉树
* 二叉树的方法用递归来解决的话，一般都是先将问题转换为一个递归的问题(同样的问题，但是规模更小了)。这道题其实是比较两个子树(A和B)的问题，A和B对称 转换为 A 的左节点和B的右节点是否对称，A的右节点和B的左节点是否对称。递归终止条件一般都与 nullptr 有关。
* 可以使用层序遍历的方法，使用一个队列同时遍历两个二叉树，这里需要注意的就是两两一组。

#### 二叉树的最大深度
* 二叉树的深度是指根节点是最小的(为0或者为1需要依照题目条件), 二叉树的高度是指从最远的节点开始的高度，根节点的高度是最高的。
* 求深度非常适合用层序遍历，求高度很适合用后序遍历（先求左子树和右子树的高度，再用最大值+1就是当前的高度）。
* 求深度也能用前序遍历，这是一个回溯的方法。
* 这道题目求最大深度，其实也就是求树的高度。求深度：前序+回溯方法，层序遍历的方法。求高度：后序遍历的方法。
* 也能当成一个整体去理解，转换为更小的问题来处理，已知左右子树的最大深度，加上当前节点的最大深度是多少？

#### 二叉树的最小深度
* 求最小深度，用层序遍历的方法很好做，找第一个左右均为 nullptr 的节点，记录它在多少层，深度就是多少。
* 递归的话，转化成更小的问题，已经左右子树的最小深度是多少，加上当前节点最小深度是多少？(与最大深度不同的点，要注意有一侧没有节点的情况)
* 一侧没有节点，其实是最大深度也应该考虑的，不过哪里的 std::max() 掩盖了这个问题。

#### 求二叉树的节点个数
* 求二叉树的节点个数，用层序遍历的话，是非常好做的，记录每层的节点个数，然后加在一起。
* 用递归的方法也是很好做，当前节点二叉树的节点个数= 左子树二叉树节点个数+右子树二叉树节点个数+1；

#### 平衡二叉树
* 这道题目其实是变相考察求二叉树的高度，求二叉树的高度就用后序遍历。
* 这题有个技巧，就是函数返回值是 int, 当是平衡二叉树的时候，就正常返回高度，否则就返回特殊标志 -1, 告知不是平衡二叉树。

#### 二叉树的所有路径
* 这道题目本质上是回溯的写法，这个回溯有技巧的地方，是其将结果利用引用的写法 `&`, 最后满足条件了，再存储到 result 中。
* 而回溯的路径部分，使用了普通的赋值语法，这样就实现了回溯的写法，非常巧妙可以好好看一看。

#### 左子树之和
* 仍然是用递归的方法，当前节点的左子节点之和=左子树的左子节点之和+右子树的左子节点之和（但是要注意左子树就是左子节点的情况）。
* 判断是一个节点是不是左子节点，只知道这个节点是不够的，要知道其父节点才行。如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子。

#### 找左下角的值
* 这道题目不太能使用普通将大问题拆成小规模的子问题，而是使用深度优先遍历的方法，每次优先左遍历，当取得最大深度的时候，记录下这个节点。
```C++
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) {
        if (root->left == NULL && root->right == NULL) {
            if (depth > maxDepth) {  // 这里很有技巧，只记录第一取得最大值得时候
                maxDepth = depth;
                result = root->val;
            }
            return;
        }
        if (root->left) {
            traversal(root->left, depth + 1); // 隐藏着回溯
        }
        if (root->right) {
            traversal(root->right, depth + 1); // 隐藏着回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```
* 本题使用层序遍历的话，是非常好解决的。

#### 路径总和
* 利用回溯的思想（深度优先搜索）, 遇到叶子节点判断是否是路径和。这道题目的技巧有两点，第一点就是不用累加而用类减，判断剩余路径是否是剩余的累加和。第二点就是返回值是 bool, 判断是否构成了。

#### 依据遍历顺序构造二叉树
* 前序和中序可以唯一确定一棵二叉树, 后序和中序可以唯一确定一棵二叉树, 前序和后序不能唯一确定一棵二叉树，因为没有中序遍历无法确定左右部分，也就是无法分割(必须有中序，其它随便加一个前序或者后序就可以唯一确定一棵二叉树)。
* 利用中序遍历和后序遍历构造二叉树：关键点主要有：
    - 不要真的传递数组，而是要传递中序的`[start, end)`, 传递后序的 `[start, end)`, 都是左开右闭的原则(因为是下一步都是在上一步的基础上进行分割，座椅可以这样做)。
    - 如果后序遍历 start==end, 直接返回 nullptr; 否则就取出后序遍历位于 end-1 处的元素，做为当前树的头节点；
    - 如果 end-start == 1 则说明只有一个节点，并没有子节点了，返回这个新建立的节点就可以了; 否则就先遍历中序数组，找到等于这个节点的值，从这里切分成左中序和右中序。
    - 对于后序的切分，是利用左后序的元素个数==左中序的元素个数, 右后序的元素个数==右中序的元素个数来实现的。
    - 最后就是递归 root-left = (); root-right = ();

* 利用前序和中序唯一确定一个二叉树: 与中序与后序一样，不过这次取的是前序中的第一个当作头节点。

#### 最大二叉树(构造二叉树)
* 这道题目仍然和上一道题目一样，确定一个值，然后分成左子树的部分和右子树的部分，这样递归下去，这道题目比上一道题目还要简单。
* 就是有个问题，不要总想着找最大值能不够优化下时间复杂度，先写出来是重要的, 这里遍历寻找最大值就可以了。
* 通过以上两种构造二叉树的方法，我们发现都是使用的是前序遍历，先确定头节点，然后再分割出左子树和右子树的区间。

#### 合并二叉树(利用两个二叉树构造二叉树的题目)
* 其实就是掌握同时遍历两棵二叉树的方法，其实当一个为 nullptr, 另一个不是的时候，就已经把这个节点及下面连接的所有子树都赋值过去了。

#### 二叉搜索树中的搜索
* 二叉搜索树是一个有序树，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；左右子树也分别为二叉搜索树。
* 二叉搜索树相比于普通的二叉树是有方向的去搜素，如果 root->val > val, 搜索左子树；如果 root->val < val, 搜索右子树。
* 迭代法在二叉搜索树中寻找值也非常好用(因为节点是有序的，方向都给确定好了，所以不用使用辅助栈或者队列)。

#### 验证二叉搜索树
* 验证二叉搜索树，要抓住 `验证二叉搜索树，就相当于变成了判断中序遍历的序列是否是递增`
* 最简单的方法，就是直接使用一个数组，保存中序遍历的结果，再使用一个 for 循环来逐一判断是不是递增的。 
* 时间复杂度 O(1) 的办法就是，就是在遍历过程中保留上一个遍历过的节点，然后与当前遍历的节点的值进行对比。
* 注意 左子树是二叉搜索树，右子树是二叉搜索树，当前节点的值大于左孩子的值，小于右孩子的值，所以也是二叉搜索树是错误的。
* 应该是当前节点的值大于左子树中最大的值，小于右子树中最小的值，当前树才是二叉搜索树。

#### 二叉搜索树中的最小差值
* 在遇到二叉搜素树中，求最值、差值之类的，把它想象成在一个有序数组中求最值，求差值(一定要好好利用二叉搜索树有序的特性)。

#### 二叉搜索树中的众数
* 从寻找二叉树最左下的的节点和这道题目中可以总结下：如果寻找第一次到达最大值的元素，可以使用 if(value>maxValue)；如果想要记录取得最大值的所有元素，可以使用 if(value==maxValue) vec.push_back(value)，if(value > maxValue) vec.clear(); vec.push_back(); 相当于每次重复最大值的时候都装入，但是更新最大值的时候就清空数组。

#### 二叉树的最近公共祖先
* 这道题目有两个假设，所有节点都是唯一的(要找的值，有且只有一个)，要找的两个节点一点是存在于二叉树中的(一定都能找到)。
* 这道题目的思路其实就是使用后序遍历，无论左右子树，只要找到了 p 或者 q 就往上返回，当左右子树有一个为 nullptr 时，返回不为 nullptr 那个，如果均不为 nullptr, 那就返回当前的节点。
```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == q || root == p || root == NULL) return root;  // 只要遇到就返回, 前提是就不重复
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != NULL && right != NULL) return root;

        if (left == NULL && right != NULL) return right;
        else if (left != NULL && right == NULL) return left;
        else  { //  (left == NULL && right == NULL)
            return NULL;
        }

    }
};
```

#### 二叉搜索树搜索最近公共祖先
* 要利用二叉搜索树的特性，当从上往下遍历的时候，第一次遇到 cur 节点是在数值 p 和 q 区间中时，那么 cur 就是 p 和 q 的公共祖先。
* 所以这道题目直接从头开始遍历就可以了，因为不需要回溯，可以一路 next。
* 递归法的思想也是很简单的，因为题目前提是一定能够找到且方向是一定正确的，所以代码直接这样写就可以了。注意这里的 if, else if，每次都是只往一个方向走，而不是普通二叉树两个方向都要寻找。
```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root->val > p->val && root->val > q->val) {
            return lowestCommonAncestor(root->left, p, q);
        } else if (root->val < p->val && root->val < q->val) {
            return lowestCommonAncestor(root->right, p, q);
        } else return root;
    }
};
```

#### 二叉搜索树插入操作(插入)
* 单纯的插入操作是非常简单的, 不涉及到结构的调整。整体思路就是，当前节点的值大于要插入的值，则向左子树插入节点（要更新下左子树）；当前节点的值小于要插入的值，向右子树插入节点（要更新下右子树）。如果当前节点为空，就创建节点，找到了插入的位置，插入其中。这里返回值是有很大的作用的，负责更新左子树和右子树。
* 这里的函数的意思是，返回以当前节点为头节点的子树中删除指定元素后的树的结构。

#### 二叉搜索树删除操作(删除)
* 二叉搜索树中删除指定的元素，就涉及到了调整二叉搜索树的结构问题。其实也是冷静下来思考就可以了，没有什么难度的。
* 其实也不是什么难得，把哪五种情况都列举了就可以了。
    - 第一种：没有找到删除的节点，遍历到空节点就返回。
    - 第二种：删除节点左右孩子都为空，直接删除即可。
    - 第三种：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点。
    - 第四种：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点。
    - 第五种：左右孩子节点都不为空，则将删除节点的（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

#### 二叉搜索树修剪操作(保留一个区间内的值，其余值全部删除)
* 这个于二叉搜索树中删除一个值还是不一样的，因为加入当前节点的值小于其保留的区间的左边界，所以当前节点所有左侧的都可以不要了，所以不会出现上一个题的那个5种情况。
* 整体思路应该是：当前节点的值如果小于区间的左边界，则修剪当前节点的右子树并返回;当前节点的值如果大于区间的右边界，则修剪当前节点的左子树并返回; 在这个中间的话，就分别再修剪这个节点的左子树和右子树分别返回。

#### 有序数组生成二叉搜索树(构建二叉搜索树)
* 这道题目其实比普通的构造二叉树要更简单(比那道构造最大二叉树简单，省去了排序的步骤)，因为分割点很好找。整体步骤仍然是(坚持左闭右开):
    - 如果 left>=right, 返回 nullptr; 否则用 mid(mid=(left+right-1)/2) 创建一个新节点；
    - 如果 right-left==1, 则返回这个新创建的节点；
    - 否则，将当前区间再分成两半，小的那半用于生成左节点，大的那半用于生成右节点；

#### 二叉搜索树转换为累加树
* 其实这道题目就是右左中的遍历方法，并将每次遍历的结果进行累加。

### 回溯算法
* 回溯是递归的副产品, 只要有递归就会有回溯。回溯法并不是什么高效的算法, 因为其本质是穷举, 穷举所有的可能, 选出我们想要的答案, 如果想让回溯算法更高效一些, 可以加一些剪枝的操作。回溯算法解决的问题都可以抽象为树形结构。能够解决的算法如下所示:
    - 组合问题: N 个数里按照一定的规则找出 k 个数的所有集合
    - 切割问题: 一个字符串按照一定规则有几种切割方式
    - 子集问题: N 个数的集合里有多少符合条件的子集
```C++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

#### 组合问题(n个数所有可能的 k 个数的组合)
* 要是用普通的 `for循环` 来做的话, 需要 k 个 `for循环` 来做。单纯的 `for循环` 是没有办法解决的。
```C++
class Solution {
private:
    // 声明两个全局变量, 其实是为了减少函数传参
    vector<vector<int>> result;
    vector<int> path;

    // n 和 k 就是两个限制条件, startIndex 是这次遍历从那个 idx 开始
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {      // 结束条件就是当前路径已经有 k 个值了
            result.push_back(path);  // 将其加入结果集合
            return;                  // 结束这条路径, 没这个的话, 永远不会结束
        }

        // 其实这里的逻辑也是, 先一个分叉走下去, 这个分叉结束以后, 往上先回溯一层, 再递归下去。
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 剪枝的地方, 不满足元素个数要求的话, 后面也没必要遍历了
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1);
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:

    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```

#### 组合总和(n个数所有可能的 k 个数的组合, 要求 k 个数的和为指定的值, 且k个值都不能重复)
* 这个其实相比于上一个题, 只是多了对一些限制, 对这 k 个数有了要求。通过再多传入一个变量来依据遍历路径统计这个要求, 来进行判断和剪枝操作。就是要注意, 除了路径要回溯之外, 这个变量也要回溯。
```C++
class Solution {
private:
    vector<vector<int>> result; // 存放结果集
    vector<int> path; // 符合条件的结果
    // 相比于上一题多了一个对 path 中当前元素之和的统计
    void backtracking(int targetSum, int k, int sum, int startIndex) {
        if (sum > targetSum) {   // 剪枝操作
            return; 
        }

        if (path.size() == k) {  // 因为 k 个元素的限制, 遍历到 k 层就可以了, 再深也没什么意义
            if (sum == targetSum) result.push_back(path);
            return; // 如果path.size() == k 但sum != targetSum 直接返回
        }

        for (int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) { // 剪枝
            // 注意这里, path 要回溯, sum 也要回溯
            sum += i; // 处理
            path.push_back(i); // 处理
            backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex
            sum -= i; // 回溯
            path.pop_back(); // 回溯
        }
    }

public:
    vector<vector<int>> combinationSum3(int k, int n) {
        result.clear(); // 可以不加
        path.clear();   // 可以不加
        backtracking(n, k, 0, 1);

        return result;
    }
};
```

#### 电话号码的字母组合
* 其实本题就不是非常直白的回溯问题了, 得需要自己来抽象。回溯算法很重要的两个东西, 一个就是本层的 `for循环` 怎么写, 一个是本层 `for循环` 循环的这个范围是通过上层递归调用传递给我的(组合优化里是数组的索引, 这道题目是递归的深度, 递归深度决定了到那个数字了, 这个数字指示这要遍历那些字符)。
```C++
class Solution {
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    string s;
    void backtracking(const string& digits, int index) {  // index 是递归深度, 不是原理数组组合中的索引了
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';        // 将index指向的数字转为int
        string letters = letterMap[digit];      // 取数字对应的字符集
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);            // 处理
            backtracking(digits, index + 1);    // 递归，注意index+1，一下层要处理下一个数字了
            s.pop_back();                       // 回溯
        }
    }

    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if (digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
```

#### 组合总和(n个数, 每个数都是无穷多个, 可以选任意多个数, 只要是组合的和为 target 就可以)
* 这道题目其实也是正常的回溯, 难度不大, 仍然要注意 `sum` 的回溯操作。
```C++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {  // 只要凑够了就可以了
            result.push_back(path);
            return;
        }

        // 如果 sum + candidates[i] > target 就终止遍历, 这里的剪枝操作
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i);  // 注意这里是 i, 而不是 i+1, i 保证了可以重复, 但是又不能取到前面的值, 防止结果重复
            sum -= candidates[i];
            path.pop_back();

        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        sort(candidates.begin(), candidates.end()); // 需要排序
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

#### 组合总和II(相比I来说, 候选元素可能重复, 且要求一个集合中的元素不能重复)
* 要注意这里的去重是对树层去重(横向), 还是对树枝去重(纵向)。这里要求结果集合不能重复, 所以是对树层去重, 所以这里要先进行排序。这里引入了 used 数组。当candidates[i] == candidates[i - 1]相同的情况下, used[i - 1] == true，说明同一树枝 candidates[i - 1] 使用过; used[i - 1] == false，说明同一树层candidates[i - 1] 使用过。
```C++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;  // 这个也要进行回溯
            backtracking(candidates, target, sum, i + 1, used); // 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        path.clear();
        result.clear();
        // 首先把给candidates排序，让其相同的元素都挨在一起, 对树层去重都要先排序。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
};

```

#### 分割回文串
* 分割问题, 其实是向连续的数组或者字符串中插入分割线来分成多个子集, 而组合问题是来寻找组合(分割问题中子串之间的相对位置是没有变化的)。
* 组合问题是每层从范围内选一个元素, 而切割问题是每层从可以插入分割线的位置, 选一个位置插入分割线。索引 i 表示在索引为 i 的元素后面插入分割线。
* 这道题目是先在每个位置插入分割线, 然后再判断前一部分是否是回文串, 是的话就将这个回文串加入到 path 中, 否则就结束以这个为开始的递归。
```C++
class Solution {
private:
    vector<vector<string>> result;
    vector<string> path; // 放已经回文的子串
    void backtracking (const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome(s, startIndex, i)) {   // 是回文子串
                // 获取[startIndex,i]在s中的子串, 取出了分割后的字串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {                                // 不是回文，跳过
                continue;
            }
            backtracking(s, i + 1); // 寻找i+1为起始位置的子串
            path.pop_back(); // 回溯过程，弹出本次已经添加的子串
        }
    }

    // 依据起始位置和终止位置, 判断是否是回文子串
    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }

public:
    vector<vector<string>> partition(string s) {
        result.clear();
        path.clear();
        backtracking(s, 0);
        return result;
    }
};
```

#### 复原 IP 地址
* 仍然是分割的方法, 注意这里判断一个字符是否合法的方法(先检验首字符是否是 `0`, 然后再依次检验每个字符是否是位于 `0` 到 `9`, 累乘+累加得到最后的结果)。
```C++
class Solution {
private:
    vector<string> result;// 记录结果

    // 这个直接在原始字符串是基础上进行增添和回溯的操作
    // startIndex: 搜索的起始位置，pointNum:添加逗点的数量
    void backtracking(string& s, int startIndex, int pointNum) {
        if (pointNum == 3) { // 逗点数量为3时，分隔结束
            // 判断第四段子字符串是否合法，如果合法就放进result中
            if (isValid(s, startIndex, s.size() - 1)) {
                result.push_back(s);
            }
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法
                s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点
                pointNum++;
                backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2
                pointNum--;                         // 回溯
                s.erase(s.begin() + i + 1);         // 回溯删掉逗点
            } else break; // 不合法，直接结束本层循环
        }
    }

    // 依据字符串, 判断所代表的数字是否合法
    // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法
    bool isValid(const string& s, int start, int end) {
        if (start > end) {
            return false;
        }

        if (s[start] == '0' && start != end) { // 0开头的数字不合法
                return false;
        }

        int num = 0;
        for (int i = start; i <= end; i++) {
            if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法
                return false;
            }
            num = num * 10 + (s[i] - '0');  // 从头到尾来累乘
            if (num > 255) { // 如果大于255了不合法
                return false;
            }
        }
        return true;
    }
public:
    vector<string> restoreIpAddresses(string s) {
        result.clear();
        if (s.size() < 4 || s.size() > 12) return result; // 算是剪枝了
        backtracking(s, 0, 0);
        return result;
    }
};

```

### 动态规划
* 动态规划中每一个状态一定是由上一个状态推导出来的。贪心算法是局部直接选最优的，和上一个状态没有关系。
* 动态规划的解题步骤是：1）确定 dp 数组及其下标的具体含义 2）确定递推公式 3）dp 数组如何初始化(那些进行初始化，这些初始化为多少) 4）确定遍历顺序(递推公式决定了遍历顺序, 遍历顺序决定了循环顺序。)

#### 爬楼梯(有多少种方法)
* 整体思想就是到第三层楼可以由第二层和第一层楼状态推导出来。
* dp[j] 表示爬到第 j 层楼梯，有 dp[j] 种走法。
* dp[j] = dp[j-1] + dp[j-2];

#### 使用最小的花费爬楼梯(代价最小)
* 整体思路就是第 j 层楼梯体力的最小花费是由到第 j-1 层楼梯所花费体力 dp[j-1] 加上花费 cost[j-1] 和 到第 j-2 层楼梯所花费体力 dp[j-2] 加上花费 cost[j-2] 的最小值。
* dp[j] 表示达到第 j 层楼梯所需要花费的最少体力。
* dp[j] = std::min(dp[j-1]+cost[j-1], dp[j-2]+cost[j-2])

#### 机器人不同路径条数（有多少种方法）
* 这道题目也是求有多少种走法，其实和爬楼梯的思想是一样的。就是将到达前几个状态的方法总数相加就可以了。
* dp[i][j] 表示从 (0, 0) 出发，到(i,j)有dp[i][j]条不同的路径。
* dp[i][j] = dp[i-1][j] + dp[i][j-1] (因为 dp[i][j] 只有这两个方向过来)
```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;  // 注意这个地方哈，是 1
        for (int j = 0; j < n; j++) dp[0][j] = 1;  // 注意这个地方哈，也是 1
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

#### 整数拆分
* 这道题目抽象出来就是，给定正整数 n(n>=2), 拆分成至少两个正整数之和，使这些正整数的乘积最大。
* 其实突然一想是很难的，但是动态规划有时候就能解决这种困难的问题。dp[j] 表示分拆正整数 j, 能够得到的最大乘积。因为我们能够假设 dp[2],....,dp[j-1] 已经求出来了，如何得到 dp[j]。可以利用 for 循环，dp[j] = max({dp[j], i*(j-i), i*dp[j-i]})。因为 dp[j-i] 是拆成2份及以上的，i×dp[j-i] 是拆成3份及以上的，那就是少了拆成2份的，i×(j-1).
* 其实 i 不需要从 1 到 j-1, 而只需要从 1 到 j/2, 因为"拆分一个数n使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的", 至少拆成2份，所以一定是遍历到 j/2 就可以了。

#### 不同的二叉搜索树
* 这道题目和上一个题目都是一个 dp 数组但是两个 for 循环，外层的 for 循环用来得到 dp[i] 的值，里层的 for 循环是用来确定两个状态 i 和 j-i, 搭配 dp[i], dp[j-i], 得出不一样的组合。注意一点就是里层 for 循环会得到多个 dp[i] 的值，这些值如何处理，也要考虑。

#### 零一背包问题
* 零一背包问题，其实抽象出来就是，背包容量有限，每个物品都有容量和价值，每个物品只能选一次，在不超过背包容量的情况下最多能够装下的最大价值。
* dp[j] 表示容量为 j 的背包，最大能够能够装下的价值。每个物品的价值，其实是可以由我们自己赋予，在一个限制的情况下，让这个自己赋予的价值最大。
* 其实我们可以发现，零一背包问题，一半都是自己将问题抽象出来，基本没有直接说自己的问题是0-1背包问题的。主要给关键词就是，不重复的选择(这个一般用别的方法都是很难的)，分成两份(一份是选择的，一份是剩下的)，求价值最大(当价值与质量相同时，就是看能否正好凑成，凑不成的话差多少的问题)。
```C++
// 一维dp数组实现
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 读取 M 和 N
    int M, N;
    cin >> M >> N;

    vector<int> costs(M);
    vector<int> values(M);

    for (int i = 0; i < M; i++) {
        cin >> costs[i];
    }
    for (int j = 0; j < M; j++) {
        cin >> values[j];
    }

    // 创建一个动态规划数组dp，初始值为0
    vector<int> dp(N + 1, 0);  // dp[0] 的价值肯定是 0, 因为每给任何空间

    // 外层循环遍历每个类型的研究材料(选择是否添加的元素一定是放在最外层的)
    for (int i = 0; i < M; ++i) {
        // 内层循环从 N 空间(最大空间)逐渐减少到当前研究材料所占空间(递减遍历是当前这个容量下，这个是加还是不加，只有一次。j >=costs[i], 是只有这些才有更新机会，不然总容量都放不下这个，肯定保持原样)
        for (int j = N; j >= costs[i]; --j) {
            // 考虑当前研究材料选择和不选择的情况，选择最大值
            dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }

    // 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值
    cout << dp[N] << endl;

    return 0;
}
```
##### 分割等和子集
* 将数组分成两个子集，使得两个子集的元素和相等 -> 转换为 0-1 背包问题就是，在重量限制的条件下，从数组中选一些数出来，最大为多少。
    - 背包重量为 sum/2;
    - 每个物品的重量和价值相等，这就会使得重量为 target 的背包能够装载的最大价值为 target。这样一转换就能够转换成是否能够选择一些元素得到目标值。
* dp[j] 容量为 j 的背包，最大能够装载的价值为多少。
```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int> dp(10001, 0);
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        // 也可以使用库函数一步求和
        // int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 == 1) return false;
        int target = sum / 2;

        for(int i=0; i<nums.size(); ++i)
        {
            for(int j=target; j>=nums[i]; --j)
            {
                dp[j] = std::max(dp[j], dp[j-nums[i]]+nums[i]);
            }
        }

        // 集合中的元素正好可以凑成总和target
        if (dp[target] == target) return true;
        return false;
    }
};
```

##### 最后一块石头的重量
* 这道题目仍然是从数组中选一些元素，然后分成两组，让两组的差值尽可能的小。不重复选元素，分成两组，这些都提示我们可以使用动态规划。
* 仍然是物品的重量与价值相等，所以 dp[sum/2] 就是在这个限制下，选择元素累加和的最大值。

##### 目标和（统计所有可能的结果）
* 这道题目其实也是从数组中不重复的选择元素，但是不是凑成目标和了，而是有多少种方法凑成目标和。
* dp[j] 此时表示填满 j 这么大容量的包，有 dp[j] 种方法。
* 注意 dp 初始化的时候，dp[0] 必须为 1, 否则结果都是 0
```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(S) > sum) return 0; // 此时没有方案
        if ((S + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (S + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];  // 这里写成 dp[j] = dp[j] + dp[j-nums[i]]
            }
        }
        return dp[bagSize];
    }
};
```

##### 一和零（一个价值，但是多个条件限制, 2个维度的背包）
* 在 0 和 1 的个数这两个维度的限制下，最大价值是多少？(这里将每个元素的价值视为 1)。但是也是零一背包问题，因为是无重复元素，价值最大。
* 这题有两个限制条件，那么dp为 dp[m][n] 表示为 dp[m][n] 最多 m 个 0 和 n 个 1 的最大子集的元素个数。
* 还有一点就是，当 value 为 1 的时候，最大价值，就变成了元素的最大个数
```C++
// 这里时3个循环
for (string str : strs) { // 遍历物品
    int oneNum = 0, zeroNum = 0;
    for (char c : str) {
        if (c == '0') zeroNum++;
        else oneNum++;
    }

    // 对两个限制条件都逆序遍历
    for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
        for (int j = n; j >= oneNum; j--) {
            dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); // 同时减少的
        }
    }
}
```
#### 完全背包问题
* 是指每件物品都有无限个（也就是可以放入背包多次）, 求解将那些物品装入背包，物品总价值最大。完全背包只是物品的个数是无限的，其余的是和零一背包一样的，都是有条件限制的。其代码模板如下：
```C++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);  // 这样就是能够使用多次
    }
}
```

#### 零钱兑换(方法数)
* 这道题目可以转换为背包问题，硬币可以重复使用，凑成总金额的组合数。但是有个问题是，对于多重背包问题，遍历顺序的不同会影响计算方法数时是组合数，还是排列数。
```C++
// 先遍历物品，对于某个容量，只会出现 {1, 5} 这种情况
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}

// 先遍历背包容量，再遍历物品，背包每个容量值都经过 1 和 5 的计算，{1， 5} 和 {5， 1} 两种情况
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

##### 组合总和(方法数)
* 可以从数组中重复选取，容量是目标和，每个元素的价值就是元素的数值。这道题目是找出元素的组合个数（不同顺序的视为不同的组合）。
* 这道题目其实很重要的一点是，求组合总数或者方法数就能反应能不能凑成目标和(方法数为0, 就不能凑成)。

##### 进阶版爬楼梯(方法数)
* 其实抽象来看，也是从一个数组种选取元素，其和到达目标值，有多少方法数。
* dp[i] 表示爬到有 i 个台阶的楼顶，有 dp[i] 种方法。

##### 零钱兑换(方法数，但是要求组合中的元素个数最少)
* 也是完全背包问题，只是需要修改下 dp 数组的定义和迭代公式。
* dp[j] 表示凑足总额为j所需钱币的最少个数为dp[j]。那么 dp[j]=min(dp[j - coins[i]] + 1, dp[j]); 外循环是硬币，内循环是容量，因为是找组合最少的元素个数，所以排列或者组合都没影响。
* 从这题可以看出，要找组合最大元素个数，也好找了。

##### 完全平方数
* dp[j] 表示和为 `j` 的完全平方数的最少数量。其实抽象出来就是, 完全平方数就是物品(可以无限次使用, 凑正整数 n 就是背包, 问凑满这个背包最少需要多少物品(一定能够凑满, 因为有 1 的存在)。) 代码如下所示:
```C++
// 其实这里先遍历背包, 还是先遍历物品都是可以的。但是先遍历背包能够提供一定的方便(给定了物品的范围)。
std::vector<int> dp(n + 1, INT_MAX);  // 初始化为最大值, 这样递推的时候才不会被初始值覆盖
dp[0] = 0;
for (int i = 0; i <= n; i++) { // 遍历背包
    for (int j = 1; j * j <= i; j++) { // 遍历物品
        dp[i] = min(dp[i - j * j] + 1, dp[i]);
    }
}
```
##### 单词拆分
* 这道题目也要抽象出来。dp[i] 定义为字符串长度为 `i` 的话, dp[i] 为 `true`, 表示可以拆分为一个或者多个在字典中出现的单词。其实好几道题都是同样的思路(逐步求每个数所需最少的完全平方数, 逐步求每个字符字串是否能够由字符串字典组成)。
```C++
class Solution {
public:
    static bool isMatch(const std::string &str, uint32_t endIdx, const std::string& subStr){
        for(uint32_t i=0; i<subStr.size(); ++i){
            if(str[endIdx-subStr.size()+i]!=subStr[i]){
                return false;
            }
        }
        return true;
    }

    bool wordBreak(string s, vector<string>& wordDict) {
        std::vector<int> dp(s.size()+1, 0);  // dp[j] 表示能够用 wordDict 表示 dp[j]。逐个来判断
        dp[0] = 1;

        for(int j=0; j<=s.size(); ++j){
            for(int i=0; i<wordDict.size(); ++i){
                if(j>=wordDict[i].size()){
                    dp[j] = std::max(dp[j], isMatch(s, j, wordDict[i]) * dp[j-wordDict[i].size()]);
                }
            }
        }

        return dp[s.size()]==1 ? true : false;
    }
};
```

##### 打家劫舍
* dp[i] 表示下标 i(包括 i) 以内的房屋, 最多可以偷窃的金额为 `dp[i]`。其实从这道题可以看出, 基本的定义就是两种, 一种是 dp[i] 是考虑前 i 个房子, 另一种是 dp[i] 是考虑前 i 个房子, 但是一定偷了第 i 个房子(这个并不一定是前 i 个房子中偷到最多的钱数)。
```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        std::vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }

        return dp[nums.size() - 1];
    }
};
```

##### 打家劫舍
* 这道打家劫舍其实是成环了。以前的成环可以使用拼接的方法，再重复一遍数组，然后进行拼接。这里的方法其实是分成多种情况来考虑。其实偷盗房屋一共就是有三种情况。首尾都不偷最大, 偷首不偷尾最大, 不偷首偷尾最大。其实整理下就是两种情况, 将除了首元素之外的都考虑偷不偷, 将除了尾元素之外的都考虑偷不偷。
```C++
// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
};
```

##### 买卖股票的最佳时机(只能买卖一次)
* 其实这道题目是特别的, 与以前的动态规划题目还是有比较多的不同的。这道题目是有很多天, 每天有两个状态。整体其实是问到那天的那个状态, 所获得最大利润。
* dp[i][0] 表示第 i 天持有股票所得最多现金; dp[i][1] 表示第 i 天不持有股票所得最多现金(其实这样定义的话, 就将每天分成了两种状态)。
```C++
class Solution{
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);  // 第 i 天持有股票可以由以前就持有, 或者这次持有(因为只能买一次, 所以一定是第一次持有) 推导出来
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);  // 第 i 天不持有股票可以由以前不持有, 以前持有这次卖出 推导出来
        }
        return dp[len - 1][1];
    }
};
```

##### 买卖股票的最佳时机 II(允许多次买卖)
* 与上一道题目相比, 允许多次买卖, 当天也是允许同时买卖的。dp 的定义方式还是一样的。说到根本，这种每天定义两个状态适用于多次买卖的场景。虽然上一道题目限制了一次买卖，但是可以通过 `dp[i][0] = max(dp[i - 1][0], -prices[i]);` 达到这个效果。
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);  // 与上一题的区别在这里, 因为允许多次买卖, 所以这里是上一次不持有股票的基础上变来的
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```

##### 买卖股票的最佳时机 III(最多买卖两次)
* 这道题目是最多买卖两次, 就不能再只设置两个状态变量啦。只设置两个状态变量不能体现最多两次这一条件。一天设置四个状态: 第一次持有股票, 第一次不持有股票, 第二次持有股票, 第二次不持有股票。以下代码中函数的返回值也是有说法的, 一定是 dp[prices.size() - 1][2] 和 dp[prices.size() - 1][4] 中最大的哪一个, 但是后者已经包含了前者, 因为允许当天的买卖。
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];  // 第一次持有
        dp[0][3] = -prices[0];  // 第二次持有
        for (int i = 1; i < prices.size(); i++) {
            dp[i][1] = max(dp[i - 1][1], 0 - prices[i]);              // 这里直接为 0, 因为是第一次持有, 手里的钱最初为 0
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);   // 第一次不持有
            // 这里先计算的 dp[i][3], 然后再 dp[i][3] 的基础上计算的 dp[i][4], 所以完全可以当天买当天卖
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);   // 第二次持有
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);   // 第二次不持有
        }
        return dp[prices.size() - 1][4];
    }
};
```

##### 买卖股票的最佳时机 IV(最多可以完成 k 笔交易)
* 这个问题其实就是最多买卖两次的抽象。整体思路就是`这次持有由上次不持有, 上次持有变换过来`。
```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

##### 最佳买卖股票的时机含冷冻期(允许多次买卖, 但是每次卖了之前多了冷静期)
* 所以其实一共是三种状态, 持有股票, 不持有股票, 冷静期, 但是冷静期必须是从刚卖出股票转过去的, 所以不持有股票要拆分成今天卖出股票+保持卖出股票的状态。
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]));  // 持有股票, 由前一天持有股票、前一天为冷静期、保持卖出股票 转换而来
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);  // 保持卖出股票, 由前一天保持卖出股票、前一天为冷静期 转换而来
            dp[i][2] = dp[i - 1][0] + prices[i];  // 今天卖出股票, 由前一天持有股票 转换而来
            dp[i][3] = dp[i - 1][2];  // 冷静期, 由前一天卖出股票转 转换而来
        }
        return max(dp[n - 1][3], max(dp[n - 1][1], dp[n - 1][2]));  // 最后一天不持有的三个状态中最大的就是最大利润
    }
};
```

##### 买卖股票的最佳时机行手续费(卖出需要手续费)
* 这道题目就是比较简单的了, 仍然是两个状态(持有股票和不持有股票), 这两个状态就能找出其中需要手续费的环节。这道题目是比较简单的题目。
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);        // 持有股票
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);  // 不持有股票, 需要手续费
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```

##### 最长上升子序列
* 子序列是由数字派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。
* 这道题目的关键其实是 dp 数组的定义。dp[i] 表示 i 之前包括 i 以 nums[i] 结尾的最长递增子序列的长度(以 nums[i] 结尾是点睛之笔)。
```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);  // dp[i] 表示 i 之前包括 i 以 nums[i] 结尾的最长递增子序列的长度。

        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {  // 这里推导 dp[i], 其实就用到了前面的 dp[1]....dp[i-1], 只有大于才加 1。
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result) result = dp[i]; // 取长的子序列
        }

        return result;
    }
};
```
##### 最长连续递增序列
* 这道题目其实比上一道题目简单，这个要求是找最长`连续`子序列。可以使用动态规划，也可以使用双指针的方法。
* 动态规划的话, dp[i] 表示 i 之前包括 i 以 nums[i] 结尾的最长递增子序列的长度。
```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int result = 1;
        vector<int> dp(nums.size() ,1);
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) { // dp[i] 只能由 dp[i-1] 推出, 在 nums[i] > nums[i-1] 时, dp[i] = dp[i-1]+1, 否则为 0
                dp[i] = dp[i - 1] + 1;
            }
            if (dp[i] > result) result = dp[i];
        }
        return result;
    }
};
```
* 双指针的方法做这道题目也是很好做的。快指针一直遍历元素，每次下一个元素大于当前元素, count 就加 1, 否则慢指针跳到快指针的位置, result=std::max(result, count), 然后 count 归 0。

##### 最长公共子数组
* 这道题目就是两个数组，找最长公共子数组。我们利用二位的 dp 数组来解题。
* dp[i][j] 表示以下标 i-1 结尾的 A 和以下标 j-1 为结尾的 B, 最长重复子数组长度为 dp[i][j](“以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串)。这样定义的好处其实就是初始条件变得很简单了。这样定义，其实 dp[0][j] dp[i][0] 都是没有意义的, 依据递推公式，我们将其设置为 0。
```C++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp (nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) {  // 为什么 dp[i][j] 只能由 dp[i-1][j-1] 来推出来, 是因为 dp[i][j] 的定义。
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    }
};
```
##### 最长公共子序列
* 最长公共子序列这里就没再用那个以 nums[i] 结尾的方式来定义 dp 数组, 那种方法能做，但是时间复杂度较高。
* 这里直接定义了 dp[i][j] 表示长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列。
* 那么 dp[i][j] 就有可能由好几种情况推出, 这个就不单是由 dp[i-1][j-1] 推出。那个题目是以结尾并连续，所以是那样的。
```C++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);  // 当不相等的时候, 肯定就是这两个里选一个大的
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```
##### 最大子序和
* 找最大和的连续子数组，返回其最大值。这道题目仍然是将 dp[i] 定义为包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。
* 递归公式其实就是，当 dp[i-1] + nums[i] > nums[i] 时，就取其和(累加), 否则就取 nums[i] 从新累加(注意不是 0)。
```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式
            if (dp[i] > result) result = dp[i]; // result 保存dp[i]的最大值
        }
        return result;
    }
};
```
##### 判断子序列
* 这道题目其实要转变一下，就是在求两个数组的最长公共子序列多少，如果最长公共子序列的长度为 s，那么 s 就是 t 的子序列。

##### 不同的子序列
* 其实这道题目就是从一个字符串 s 中删除一些字符，求有多少种删除方式可以使得删除后的结果为 t(也是求 s 的子序列中 t 出现的次数)。这道题目仍然是动态规划, 只不过是利用二维的dp数组。dp[i][j] 表示以 i-1 结尾的 s 子序列中出现以 j-1 结尾的 t 的个数(注意这里是结尾的用法)。如果要是将 dp 数组声明为一维, dp[i] 表示以 i-1 结尾的 s 子序列中出现 t 的个数, 这样递推关系不好写。因为 t 在 s 子序列中出现的次数不仅取决于 s 的结尾字符, 还取决于 t 和 s 的所有前缀组合关系。
* 使用二维的写法，可以将这一过程化简。
```C++
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>> dp(s.size() + 1, vector<uint64_t>(t.size() + 1));
        for (int i = 0; i < s.size(); i++) dp[i][0] = 1;  // t 为空字符串, 相当于全部删除就可以了
        for (int j = 1; j < t.size(); j++) dp[0][j] = 0;  // s 为空字符串, 组成不了
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= t.size(); j++) {
                if (s[i - 1] == t[j - 1]) {  // 当相等的时候, 分成s中使用 s[i-1] 和 不使用 s[i-1]
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                } else {  // 不相等的时候, 直接去掉就可以了
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};
```

##### 两个字符串的删除操作
* dp[i][j] 表示以 i-1 结尾的字符串 word1 和以 j-1 结尾的字符串 word2, 要想达到相等, 所需要删除元素的最少次数。
```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;  // word2 是空字符串
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;  // word1 是空字符串
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {  // 两个字符串结尾的字符相等, 那就直接对比前面的需要多少步就可以了
                    dp[i][j] = dp[i - 1][j - 1];
                } else {  // 两个字符串结尾的字符不相等的时候, 先删除一个字符结尾的, 再与另一个字符对比
                    dp[i][j] = min(min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i-1][j-1]+2);
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

##### 编辑距离
* 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数。dp[i][j] 表示以下标 i-1 为结尾的字符串 word1, 以下标 j-1 为结尾的字符串 word2, 最近的编辑距离为 dp[i][j]。
* 其实能够发现对这种类型的dp数组, 使用 dp[i] 表示以 i-1 结尾就是图个初始化方便。
```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;  // word2 为空, 直接删除就可以了
        for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;  // word1 为空, 直接删除就可以了
        for (int i = 1; i <= word1.size(); i++) {
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i - 1] == word2[j - 1]) {  // 相等的时候, 直接不需要编辑, 直接比后面就可以了
                    dp[i][j] = dp[i - 1][j - 1];
                }
                else {  // 不相等的时候, 替换, 删除, 删除
                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

##### 回文字串(也能求最长回文子串)
* 回文串: 字符串反转后和原字符串相同，比如aba。这道题目 dp 数组是非常值得学习的。dp[i][j] 表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。
```C++
class Solution {
public:
    int countSubstrings(string s) {
        // dp[i][j] 表示区间 [i,j] 左闭右闭，这点好好学习
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        int result = 0;
        for (int i = s.size() - 1; i >= 0; i--) {  // 注意遍历顺序 因为 dp[i][j] 由 dp[i+1][j-1] 推出的
            for (int j = i; j < s.size(); j++) {  // 推个右上角就好了, 因为 j >= i
                if (s[i] == s[j]) {
                    if (j - i <= 1) { // 情况一 和 情况二  i==j 是只有一个字符,  j-i==1 是有两个字符
                        result++;
                        dp[i][j] = true;
                    } else if (dp[i + 1][j - 1]) { // 情况三, 这个是三个字符及以上
                        result++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return result;
    }
};
```
* 这道题目也可以使用双指针的方法。首先不是判断字符串是否是回文字串, 而是找回文字串的个数。所以要找中心点。
```C++
class Solution {
public:
    int countSubstrings(string s) {
        int result = 0;
        for (int i = 0; i < s.size(); i++) {
            result += extend(s, i, i, s.size());     // 以i为中心, 以一个元素为中心
            result += extend(s, i, i + 1, s.size()); // 以i和i+1为中心, 以两个元素为中心
            // 其余以 3,4 个元素为中心都可以由以上两种情况凑出来
        }
        return result;
    }

    // 这个函数的主要任务是找 s 中以 [i, j] 为中心开始的回文子串的个数
    int extend(const string& s, int i, int j, int n) {
        int res = 0;
        while (i >= 0 && j < n && s[i] == s[j]) {
            i--;
            j++;
            res++;
        }
        return res;
    }
};
```
##### 最长回文子序列
* dp[i][j] 表示字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。
```C++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;  // 左右相等则加 2
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);  // 左右找个最大的
                }
            }
        }
        return dp[0][s.size() - 1];  // 注意返回值, 其实返回值也表明了遍历顺序
    }
};
```

### 图论
* 无向图只有度的概念，有几条边连接该节点，该节点就有几度。有向图中每个节点有出度和入度(出度: 从该节点出发的边的个数, 入度: 指向该节点的边的个数)。
* 无向图中任意两个节点都可以到达，就是连通图，如果有节点不能到达其他节点，则为非连通图。有向图中任何两个节点都是可以相互到达的，就是强连通图。无向图中的极大连通子图称之为该图的一个连通分量。有向图中极大强连通子图称之为该图的强连通分量。
* 图的构造方法有邻接矩阵、邻接表的方法。邻接矩阵的方法是从节点的角度来出发的，使用二维数组来表示图结构。grid[2][5] = 6, 有向图，表示节点2 指向 节点5，边的权值为6。grid[2][5]=6, gird[5][2]=6, 无向图，表示节点2 与 节点5 相互连通，权值为6。
* 邻接表的方法，使用数组+链表的方式。邻接表是从边的角度出发的，有多少条边就会申请对应大小的链表
* 邻接矩阵的优点：检查任意两个顶点是否存在边非常快，适合稠密图(边数接近顶点平数平方图中)  缺点：稀疏图会导致申请过大的二维数组造成资源的浪费，遍历边的时候，要遍历整个 n*n 矩阵，时间浪费。
* 邻接表的优点：对于稀疏图，只需要存储边，空间利用率高；缺点：检查两个点的是否存在边效率较低。
```C++
// 邻接矩阵的方法。用二维数组来表示图的结构。一般有 1...n 共 n 个节点。因为节点编号是从 1 开始，为了节点标号和下标对齐，申请了 (n+1)*(n+1) 的二维数组。
vector<vector<int>> graph(n + 1, vector<int>(n + 1, 0));

while (m--) {
    cin >> s >> t;
    // 使用邻接矩阵 ，1 表示 节点s 指向 节点t
    graph[s][t] = 1;  // 这个是有向图，无向图还得再加一行
}

// 邻接表的方法。数组+链表的方式。节点编号从1到n，所以申请 n+1 这么大的数组
vector<list<int>> graph(n + 1); // 邻接表，list为C++里的链表
while (m--) {
    cin >> s >> t;
    // 使用邻接表 ，表示 s -> t 是相连的
    graph[s].push_back(t);  // 这个是有向图，无向图还得再加一行
}
```

##### 深度优先搜索(dfs)
* 深度优先搜索是可着一个方向去搜索，直到遇到绝境(终止条件), 再换方向搜索(涉及到了回溯)。
* 代码框架如下
```C++
void dfs(参数) {
    if (终止条件)  // 通常时到达目标或者搜过了访问过的点
    {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```
* (有向无环图从起始点找到终点)这道题目是有向无环图，也就是不会成环，所以在找从节点 1 到节点 n 的路径的时候，不用判断下一个点是否走过(肯定未走过，如果走过就有环了)。
```C++
vector<vector<int>> result; // 收集符合条件的路径
vector<int> path; // 1节点到终点的路径

path.push_back(1); // 无论什么路径已经是从1 节点出发
dfs(graph, 1, n); // 开始遍历
// graph 是地图, x 是当前达到的节点, n 是目标节点
void dfs (const vector<list<int>>& graph, int x, int n) {
    if (x == n) { // 找到符合条件的一条路径
        result.push_back(path);
        return;
    }
    for (int i : graph[x]) { // 找到 x指向的节点
        path.push_back(i); // 遍历到的节点加入到路径中来
        dfs(graph, i, n); // 进入下一层递归
        path.pop_back(); // 回溯，撤销本节点
    }
}
```

##### 广度优先搜索(bfs)
* 广度优先搜索适合解决两个点之间的最短路径问题。广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。
* 代码框架如下: 
```C++
// 以下代码中并未有记录第几步骤，因为只是染色就可以了。层序遍历就可以每次先记录队列的长度，然后记录是第几步。注意加入队列立即标记的事情。
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited 标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) {     // 如果节点没被访问过
                que.push({nextx, nexty});     // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问。这个代码非常关键。
            }
        }
    }
}
```

##### 与岛屿有关的问题
* 一般来说，岛屿问题都需要邻接矩阵存储地图，并初始化一个与地图同样大小的 visited 数组来记录每个点是否访问过。
* 岛屿数量问题不涉及具体的遍历方式，只要能把相邻且属性相同的节点标记上就行。一般来说，深度优先遍历和广度优先遍历都可以。
```C++
int n, m;
cin >> n >> m;
vector<vector<int>> grid(n, vector<int>(m, 0));
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        cin >> grid[i][j];
    }
}

vector<vector<bool>> visited(n, vector<bool>(m, false));

// 从每个点能走的四个方向, [4][2] 相当于是两两一组, {0, 1} 上   {1, 0} 左  {-1, 0} 右  {0, -1} 下
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
```
###### 岛屿数量
* 整体思路就是遇到一个没有遍历过的节点陆地，计数器就加 1，然后把该节点陆地所能遍历到的陆地都标记上。在遇到标记过的陆地节点和海洋节点的时候，直接跳过。最终计数器的值就是最终岛屿的数量。

###### 岛屿的最大面积
* 这个与岛屿数量其实思路一致。就是声明一个全局变量，每次找到第一个为遍历的陆地时候，就置为1，剩下的交给 bfs 或 dfs 来统计每个岛屿的面积。

###### 孤岛的总面积
* 可以先从边界开始，将所有靠海的连通陆地都变成海洋。余下的岛屿的面积就是孤岛的面积。注意如何从四个边界将岛的面积变成海洋。
```C++
// 从左侧边，和右侧边 向中间遍历, 共用一个循环
for (int i = 0; i < n; i++) {
    if (grid[i][0] == 1) dfs(grid, i, 0);
    if (grid[i][m - 1] == 1) dfs(grid, i, m - 1);
}

// 从上边和下边 向中间遍历, 公用一个循环
for (int j = 0; j < m; j++) {
    if (grid[0][j] == 1) dfs(grid, 0, j);
    if (grid[n - 1][j] == 1) dfs(grid, n - 1, j);
}

// 这个就是一个染色的 dfs 写法, x, y 表示从那个地方开始染色
void dfs(vector<vector<int>>& grid, int x, int y) {
    grid[x][y] = 0;
    count++;
    for (int i = 0; i < 4; i++) { // 向四个方向遍历
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        // 超过边界
        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;
        // 不符合条件，不继续遍历
        if (grid[nextx][nexty] == 0) continue;

        dfs (grid, nextx, nexty);
    }
    return;
}
```
###### 沉没孤岛
* 其实这道题目与孤岛总面积是类似的。我们也是从两侧边界开始遍历，然后将与边界接壤的土地都置为2, 那么此时 水是 0, 与陆地接壤的土地是 1, 不接壤的是 2。将为 1 的值都赋值为 0 即可。
* 从这道题目思考来看，解决上一道题目也可以用这种方法，直接统计元素为 1 的个数即是孤岛的总面积。

###### 水流问题
* 整体思想是从第一组边界上的节点逆流而上，将遍历过的所有节点都标记上。同样从第二组边界上的节点逆流而上，将遍历过的节点也都标记上。
* 逆流而上(高度不能降低)确定了每一个点可以选择的遍历点。这道题需要用两个 visited 来分别存储第一组边界 和 第二组边界。

###### 建造最大岛屿
* 仍然是遍历的方式，修改地图，将每个岛屿都有唯一的编号，然后再通过 map 来记录这个编号岛屿的面积。然后遍历未访问的节点, 将其置为 1, 然后看其周围岛屿都是什么岛屿，面积是多少，相加得到最终的结果。注意统计周围岛屿的时候，可以使用 set 存储相邻的岛屿，避免重复加入。
```C++
vector<vector<bool>> visited(n, vector<bool>(m, false)); // 标记访问过的点
unordered_map<int ,int> gridNum;
int mark = 2; // 记录每个岛屿的编号
bool isAllGrid = true; // 标记是否整个地图都是陆地
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        if (grid[i][j] == 0) isAllGrid = false;
        if (!visited[i][j] && grid[i][j] == 1) {
            count = 0;
            dfs(grid, visited, i, j, mark); // 将与其链接的陆地都标记上 true
            gridNum[mark] = count; // 记录每一个岛屿的面积
            mark++; // 记录下一个岛屿编号
        }
    }
}
```
###### 岛屿的周长
* 这道题目其实用不到 BFS 和 DFS，思路就是遍历每个陆地，然后判断其上下左右所有的水，遇到水就加 1，最终得到岛屿的周长。
* 这道题目其实可以扩展下，有多个岛屿，判断每个找最长的岛屿的周长。其实就是可以先通过 BFS 和 DFS 给不同的岛屿不同的值。然后整体遍历，统计每个岛屿的周长，最终找打最大值。

##### 字符串接龙
* 给了一个 beginStr 和一个 endStr, 通过中间状态 strList 的变换转到最终 endStr 的状态。这里并没有初始建图，因为初始建图的目的其实也就是找到当前节点和那些节点相连。
* 这里判断相连的方法就是，将一个字符串的字符修改一次，看是否出现在 strList 中，出现的话，就代表可达。
* 因为是求无向图的最短路径，所以这个题目用了广度优先搜索，而且需要 visited 来避免重复访问。
* 这里用一个记录 visited_map 记录了每个点是否访问过，和到达这个访问点是多少步。因为这里并没有结构化的表示，所以直接使用 set/map 存储已经访问过的节点就可以了。如果不这样的话，就得统计每次加入节点的个数，从而确定什么时候 path 加 1。
```C++
#include <iostream>
#include <vector>
#include <string>
#include <unordered_set>
#include <unordered_map>
#include <queue>
using namespace std;
int main() {
    string beginStr, endStr, str;
    int n;
    cin >> n;
    unordered_set<string> strSet;
    cin >> beginStr >> endStr;
    for (int i = 0; i < n; i++) {
        cin >> str;
        strSet.insert(str);
    }

    // 记录strSet里的字符串是否被访问过，同时记录路径长度
    unordered_map<string, int> visitMap; // <记录的字符串，路径长度>

    // 初始化队列
    queue<string> que;
    que.push(beginStr);

    // 初始化visitMap
    visitMap.insert(pair<string, int>(beginStr, 1));

    while(!que.empty()) {
        string word = que.front();
        que.pop();
        int path = visitMap[word]; // 这个字符串在路径中的长度

        // 开始在这个str中，挨个字符去替换
        for (int i = 0; i < word.size(); i++) {
            string newWord = word; // 用一个新字符串替换str，因为每次要置换一个字符

            // 遍历26的字母
            for (int j = 0 ; j < 26; j++) {
                newWord[i] = j + 'a';
                if (newWord == endStr) { // 发现替换字母后，字符串与终点字符串相同
                    cout <<  path + 1 << endl; // 找到了路径 
                    return 0;
                }
                // 字符串集合里出现了newWord，并且newWord没有被访问过
                if (strSet.find(newWord) != strSet.end()
                        && visitMap.find(newWord) == visitMap.end()) {
                    // 添加访问信息，并将新字符串放到队列中
                    visitMap.insert(pair<string, int>(newWord, path + 1));
                    que.push(newWord);
                }
            }
        }
    }

    // 没找到输出0
    cout << 0 << endl;
}
```
##### 有向图的完全可达性(有向图，判断从指定节点是否能到达其余所有节点)
* 注意这个是个有向图，并未说无环，所以要使用 visited 来防止重复访问。最终也是通过判断 visited 是否都为 true 来判断是否有可以到达所有节点。整体就是个 bfs 或者 dfs 的过程。

##### 并查集
* 当我们需要判断两个元素是否在同一个集合里的时候，就要想到用并查集。并查集的两个主要功能：将两个元素添加到一个集合中 和 判断两个元素在不在同一个集合中。
* 并查集的空间复杂度为 O(n), 路径压缩后并查集的时间复杂度在 O(logn) 与 O(1) 之间，并且随着查询或者合并操作的增加, 时间复杂度越来越趋向于 O(1)。
* 整体代码模板如下：
```C++
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构

// 并查集初始化, 每个元素的父亲都是自己。
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}

// 并查集里寻根的过程, 注意路径压缩的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;  // 注意这里是让 father[v] = u 而不是, v=u, 这一点很重要, 在这里 u=v 也没有什么意义的。
}
```
##### 寻找存在的路径(无向图中，判断指定节点是否能够到达指定节点)
* 因为无向图是各个节点都是双向链接的，那么判断一个顶点到另一个顶点有没有有效路径其实就是看着两个顶点是否在同一个集合里。

##### 冗余连接
* 数可以看成是一个图(有 n 个节点和 n-1 条边的连通无环无向图)。给定拥有 n 个节点的和 n 条边的连通无向图，找出一条可以删除的边，删除后图可以变成一棵树。
* 其实就是用并查集，每次将新的边加入到集合中的时候，都先判断这个边的两个节点是否都在同一个集合中，如果在的话这个就是冗余的那个边。

##### 最小生成树(无向图中最小连通子图)
* prim 算法和 Kruskal 都是用于专门解决无向图中的最小生成树问题。最小生成树是所有节点的最小连通子图，以最小的成本(边的权值)将图中的所有节点连接在一起。
* 图中有 n 个节点，一定可以用 n-1 条边将所有节点连接到一起, 如何选择这 n-1 条边就是算最小生成树算法任务所在。
* prim 算法的核心思想: minDist 数组记录着每一个节点距离最小生成树的最近距离
    - 第一步，选距离生成树最近的节点
    - 第二步，最近节点加入到生成树中
    - 第三步，更新非生成树节点到生成树的距离(更新minDist数组)
```C++
#include<iostream>
#include<vector>
#include <climits>

using namespace std;
int main() {
    int v, e;
    int x, y, k;
    cin >> v >> e;
    vector<vector<int>> grid(v + 1, vector<int>(v + 1, 10001));
    while (e--) {
        cin >> x >> y >> k;
        grid[x][y] = k;
        grid[y][x] = k;
    }

    vector<int> minDist(v + 1, 10001);    // 依据边的权的最大值来设置, 记录着每一个节点距离最小生成树的最近距离
    vector<bool> isInTree(v + 1, false);  // 记录每个节点是否加入到树中了, 防止重复遍历

    //加上初始化
    vector<int> parent(v + 1, -1);        // 记录着每个节点的父节点

    for (int i = 1; i < v; i++) {  // 因为 v 个节点，找到 v-1 条边就够了，所以只循环 v-1 次
        // 第一步，选距离生成树最近的节点
        int cur = -1;
        int minVal = INT_MAX;
        for (int j = 1; j <= v; j++) {  // 在第一次找的时候，找到了第一个节点(任意从一个节点出发都可以)
            if (!isInTree[j] &&  minDist[j] < minVal) {
                minVal = minDist[j];
                cur = j;
            }
        }

        // 第二步, 最近节点加入到生成树中
        isInTree[cur] = true;  

        // 第三步, 更新其余不在树中的节点到二叉树的最近距离
        for (int j = 1; j <= v; j++) {
            if (!isInTree[j] && grid[cur][j] < minDist[j]) {
                minDist[j] = grid[cur][j];

                parent[j] = cur; // 记录边
            }
        }
    }
    // 输出 最小生成树边的链接情况
    for (int i = 1; i <= v; i++) {
        cout << i << "->" << parent[i] << endl;
    }
}
```
* prim 算法是维护节点的集合，而 Kruskal 是维护边的集合。kruskal 的思路是:
    - 边的权值排序，优先选最小的边加入到生成树中
    - 遍历排序后的边：
        - 如果边首尾的两个节点在同一个集合，说明连上这个条边图中会出现环, 就不加入这条边。
        - 如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入到同一个集合。
* kruskal 的整体思路其实是更简单的，而且只要对边进行一次排序，然后就一直找不成环的最小距离边就可以了, 就是一种贪心算法。
```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 用来保存边及对应的权值
struct Edge {
    int l, r, val;
};

// 依据题目中给的节点个数来初始化数组
int n = 10001;
vector<int> father(n, -1); 

void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}

int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); 
}

void join(int u, int v) {
    u = find(u); 
    v = find(v); 
    if (u == v) return ; 
    father[v] = u;
}

int main() {
    int v, e;
    int v1, v2, val;
    vector<Edge> edges;
    int result_val = 0;
    cin >> v >> e;
    while (e--) {
        cin >> v1 >> v2 >> val;
        edges.push_back({v1, v2, val});
    }

    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {
            return a.val < b.val;
    });

    vector<Edge> result; // 存储最小生成树的边
    init();

    for (Edge edge : edges) {

        int x = find(edge.l);
        int y = find(edge.r);

        if (x != y) {
            result.push_back(edge); // 保存最小生成树的边
            result_val += edge.val; 
            join(x, y);
        }
    }

    // 打印最小生成树的边
    for (Edge edge : result) {
        cout << edge.l << " - " << edge.r << " : " << edge.val << endl;
    }

    return 0;
}
```

##### 拓扑排序
* 给出一个有向图，把这个有向图转换成线性的排序，就叫做拓扑排序(拓扑排序也能检测这个有向图是否是有环，存在环的话不能做线性排序), 其也是图论中判断有向无环图的常用方法。
* 拓扑排序的整体思路如下：
    - 找到入度为 0 的节点，加入结果集合。
    - 将该节点从图中移除(实际操作的时候，是将与其相邻的节点的入读都减 1)。
* 如何判断有环呢？结果集中的元素不等于图中节点的个数，就可以认为有向图中一定是有环的。
```C++
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

int main() {
    int m, n, s, t;
    cin >> n >> m;
    vector<int> inDegree(n, 0); // 记录每个节点的入度

    unordered_map<int, vector<int>> umap; // 记录文件依赖关系, 其实也可以使用邻接链表的方法
    vector<int> result; // 记录结果

    while (m--) {
        // s->t，先有s才能有t
        cin >> s >> t;
        inDegree[t]++; // t的入度加一
        umap[s].push_back(t); // 记录s指向哪些文件
    }
    // 第一次先寻找入读为 0 的节点, 之后为什么没有这个操作呢？因为之后出现入读为零的节点，一定都是与被删除节点连接的节点。
    queue<int> que;
    for (int i = 0; i < n; i++) {
        // 入度为0的文件，可以作为开头，先加入队列
        if (inDegree[i] == 0) que.push(i);
        //cout << inDegree[i] << endl;
    }
    // int count = 0;
    while (que.size()) {
        int  cur = que.front(); // 当前选中的文件
        que.pop();
        //count++;
        result.push_back(cur);
        vector<int> files = umap[cur]; //获取该文件指向的文件
        if (files.size()) { // cur有后续文件
            for (int i = 0; i < files.size(); i++) {
                inDegree[files[i]] --; // cur的指向的文件入度-1
                if(inDegree[files[i]] == 0) que.push(files[i]);
            }
        }
    }

    if (result.size() == n) {
        for (int i = 0; i < n - 1; i++) cout << result[i] << " ";
        cout << result[n - 1];
    } else cout << -1 << endl;

}
```

##### dijkstra 算法(单源最短路径问题, 有向图, 无向图均可, 要求图中不存在负权值)
* dijkstra 算法用于: 在有权图（权值非负数）中求从起点到其他节点的最短路径算法。
* dijkstra 算法可以同时求起点到所有节点的最短路径。
* dijkstra 算法的核心思想如下: minDist 
    - 选源点到哪个节点近且该节点未被访问过。
    - 将该选好的节点标记为访问过。
    - 然后更新该节点连接的且未被访问的节点相距源的距离。
```C++
#include <iostream>
#include <vector>
#include <climits>
using namespace std;
int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<vector<int>> grid(n + 1, vector<int>(n + 1, INT_MAX));
    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        grid[p1][p2] = val;
    }

    int start = 1;
    int end = n;

    std::vector<int> minDist(n + 1, INT_MAX);  // 记录每个节点距离源点的最短距离, 初始化为最大值
    std::vector<bool> visited(n + 1, false);   // 记录这个节点是否访问过

    minDist[start] = 0;  // 源点距离原点的距离置为 0 就可以了
    for (int i = 1; i <= n; i++) {

        // 第一步, 找未访问过且距离距离源点最近的点
        int minVal = INT_MAX;
        int cur = 1;
        for (int v = 1; v <= n; ++v) {
            if (!visited[v] && minDist[v] < minVal) {
                minVal = minDist[v];
                cur = v;
            }
        }

        // 第二步, 将这个点标记为访问过
        visited[cur] = true;

        // 第三步, 更新与这个点相连的点到源点的最短距离(将 cur 当作跳板)
        for (int v = 1; v <= n; v++) {
            if (!visited[v] && grid[cur][v] != INT_MAX && minDist[cur] + grid[cur][v] < minDist[v]) {
                minDist[v] = minDist[cur] + grid[cur][v];
            }
        }

        // 打印日志：
        cout << "select:" << cur << endl;
        for (int v = 1; v <= n; v++) cout <<  v << ":" << minDist[v] << " ";
        cout << endl << endl;;

    }
    if (minDist[end] == INT_MAX) cout << -1 << endl;
    else cout << minDist[end] << endl;
}
```