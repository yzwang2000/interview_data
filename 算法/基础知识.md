## 数据结构基础套路
### 概述
1. 好算法的本质？
* 正确性。算法应该能够正确地解决求解问题。
* 可读性。算法应该具备良好的可读性，以帮助人们理解。
* 健壮性。输入非法数据时，算法能够适当地做出反应或者进行处理，而不会产生莫名奇妙的输出结果。
* 低的时间复杂度和低的空间复杂度。

2. 算法效率的度量？
* 时间复杂度：事前预估算法时间开销`T(n)`与问题规模`n`的关系。
    - 加法规则：`T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))`
    - 乘法规则：`T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))`
    - 顺序执行的代码只会影响常数项，可以忽略；只需要找循环中的一个基本操作，分析它的执行次数与n的关系即可；如果有多层嵌套循环，只需要关注最深层循环循环了几次。
    - 时间复杂度有最好时间复杂度、最坏时间复杂度、平均时间复杂度。主要关注最坏和平均时间复杂度。
* 空间复杂度：空间开销（内存开销）与问题规模`n`之间的关系。
    - 加法规则：`T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))`
    - 空间复杂度主要是与`数组的大小`和`递归调用的深度`有关。

### 数组
数组是存放在连续内存空间上的相同类型数据的集合, 可以通过下标索引的方式获取得到下标对应的数据；因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址；C++中二维数组是连续分布的。

#### 二分查找
1. 使用二分法的前提条件：1）数组有序 2）数组中无重复元素
2. 二分法的实现的注意事项：1）定义区间 [left, right]（左闭右闭） 2）循环条件(left<=right) 3）middle=left + (right-left)/2, 防止 left+right 溢出 3）通过判断 nums[middle] 与 target 的关系来决定更新 right, 还是 left, 还是直接返回 middle。4）注意更新的是 middle-1 和 middle+1, 而不是 middle。
3. 时间复杂度 `O(logn)`, 空间复杂度 O(1)。

#### 删除数组中元素 val
1. 整体思路就是, 将所有不等于 val 的值都移到数组前面, 记录非 val 值的个数, 然后直接 resize。
2. 这个题可以使用双指针的方法：1）快指针：遍历新元素，保存新元素的索引 2）慢指针：更新数组的下标的位置(这个起始也就代表了元素的个数)
3. 快指针一直向前遍历所有元素，如果快指针指向的元素不等于 val, 就更新到慢指针指向的位置，慢指针+1；如果快指针指向的元素等于 val，不更新到满指针指向的元素

#### 滑动窗口
滑动窗口是不断地调整子序列的起始位置和终止位置，从而得到我们想要的结果。
1. 滑动窗口本该是用两个 for 循环来做(一个起始位置，一个终止位置，时间复杂度为 O(n^2))
2. 而利用双指针法，利用一个 for 来遍历起始/终止位置, 再用一个指针来自动调节窗口的终止/起始位置。
3. 指针如何移动呢？主要考虑题目条件, 连续累加和超过？（移动一个元素）, 有些题目也有可能移动到快指针的位置
4. 注意这里的`双指针要都包含边界`, 所以得出个数的时候要 终止位置索引-起始位置索引+1。

#### 螺旋矩阵
这道题目，主要核心点就在于以下几点：1）确定需要循环的次数 n/2，n 为奇数的时候需要手动填充中间的值 2）每次循环开始的位置 3）每次循环开始的时候都确定 i 和 j
4）四个循环公用一套 i 和 j 5）填充的区间都是左闭右开，这样四个循环都是对称的。

### 链表
1. 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域，最后一个节点的指针域指向 `null`。链表分为单链表、双链表、循环链表。C++ 中链表的定义方式如下：
```C++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(nullptr) {}  // 节点的构造函数
};
```
2. C++中删除链表中某个节点：`A->B->C`(删除其中的 B 节点), 保存下 A 指向的下一个节点, 让 A 指向 C, 释放 A 指向的下一个节点。
3. C++中增添链表中某个节点：`A->C`(A->C 中增添 B), 保存 A 指向的下一个节点, 让 A 指向 B, 让 B 指向保存的 A 指向的下一个节点(C)。

#### 虚拟头节点
通常可以通过增加虚拟头节点的操作来使得对链表的操作进行统一。链表的一大问题就是操作当前节点必须要找前一个节点才能操作，因为头节点没有前一个节点了。
1. 添加和删除虚拟头节点的操作可以使得操作链表(插入，删除，索引)变得简单
```C++
ListNode* dummyHead = new ListNode(0);  // 设置虚拟头节点
dummyHead->next = head;  // 将虚拟头节点指向 head

// 返回新的头节点
head = dummyHead->next;
delete dummyHead;
return head;
```
#### 反转链表
1. 反转头节点不需要使用虚拟头节点。
2. 使用 `双指针的方法`。fast 指针初始化为头节点, slow 指针初始化为 nullptr。循环逻辑就是, 用 tmp 临时保存 fast->next, 然后 cur->next 指向 slow，更新 pre = cur, cur=tmp, 直到 cur == nullptr, 此时返回 链表头节点 pre。

#### 两两交换链表中的节点
1. 需要使用虚拟头节点。
2. 做链表的题目, 一定要把画图，用一组数据进行模型, 把每个步骤清楚的标注出来, 依据标注出来的结果来写代码。
3. 注意边界条件, 根据到结尾的第几个节点终止来确定循环的边界条件。本题是 `while(cur->next != nullptr && cur->next->next != nullptr)`。

#### 删除链表的倒数第 N 个节点
1. 需要使用虚拟头节点。
2. 使用双指针的逻辑, 快指针和慢指针都初始指向虚拟头节点。快指针先移动 N+1 步, 然后快慢指针一起移动, 直到快指针为 nullptr, 此时参数慢指针的next指向的节点。

#### 求链表长度的方法
1. 求链表长度时, 主要循环终止条件, 如下
```C++
int lenA = 0;
while(curA!=NULL){
    ++lenA;
    curA = curA->next;
}
```
2. 对于两个链表或者两个数组, 不能确定谁的元素多，谁的元素少时, 直接先判断长度, 然后用 `std::sawp` 进行交换, 保证想要的那个是元素多的。
```C++
curA = headA;
curB = headB;
// 让curA为最长链表的头，lenA为其长度
if (lenB > lenA) {
    swap (lenA, lenB);
    swap (curA, curB);
}
```

#### 判断链表是否有环, 并找到环的入口
1. 判断入口是否有环，使用快慢指针的方法, 这道题目不用虚拟头节点。
2. 快慢指针都从头指针出发，快指针每次移动2步，慢指针每次移动1步, 如果快指针等于慢指针, 则说明有环, 如果快指针检测到有 nullptr, 那就是无环。
3. 环的入口需要依据一个数学公式，从头节点到环的入口和从相遇点到环的入口，所走路程是相同的（前提仍然是 fast 每次走两步，slow 每次走一步依据这个公式来做）。

### 哈希表
哈希表是根据关键码的值而直接进行访问的数据结构，哈希表用来快速判断一个元素是否出现在集合中。哈希函数，通过hashCode把名字转化为数值，一般hashCode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。可以使用拉链法和线性探测法来解决哈希碰撞问题：
    * 拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间, 哈希表大小一定要合适，要映射尽可能的均匀。
    * 使用线性探测法，一定要保证 tableSize 大于 dataSize, 我们需要依靠哈希表中的空位来解决碰撞问题。
| 集合 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
|:----:|:-------:|:--------:|:---------------:|:------------:|:-------:|:--------:|
| std::set | 红黑树 | 有序 | 否 | 否 | O(log n) | O(log n) |
| std::multiset | 红黑树 | 有序 | 是 | 否 | O(log n) | O(log n)|
| std::unordered_set | 哈希表 | 无序 | 否 | 否 | O(1) | O(1) |

|映射	|底层实现|	是否有序|	数值是否可以重复|	能否更改数值|	查询效率|	增删效率|
|:----:|:-------:|:--------:|:---------------:|:------------:|:-------:|:--------:|
|std::map|	红黑树|	key有序|	key不可重复	|key不可修改	|O(logn)	|O(logn)|
|std::multimap|	红黑树|	key有序|	key可重复|	key不可修改|	O(log n)	|O(log n)|
|std::unordered_map| 哈希表|	key无序|	key不可重复|	key不可修改|	O(1)|	O(1)|

#### 有效的字符异位词
* 对于有限的、连续的、跨度小的哈希值，比如 26 个英文字母，可以直接映射到一个数组中，'a'映射到下标为0，'z'映射到下标为25；
* 这道题目是 3 个循环，第一个循环先统计其中一个字符串各个字符出现的次数并加1，第二个循环统计另一个字符串各个字符出现的次数并减1，最后一个循环用来判断各个元素是否为0
* 为什么遇到哈希问题不直接使用 unordered_set 系列容器呢，是因为 unordered_set 系列容器不仅空间占比大，而且把数值映射到key上都要做 hasd 计算的，计算速度慢。

#### 两个数组的交集
* 求两个数组的交集，其实需要两个 unordered_set, 第一是将其中一个数组去重，遍历另一个数组的元素，若有发现其在第一个 unordered_set 中, 则将其元素加入到另一个 unordered_set 中。
* set 系列用于哈希值少，比较分撒，跨度很大的场景，也就是数组不适合的场景，都用 set 来做。
* 这里的有一些语法需要注意：set 与 vector 之间的转换, map 与 vector 之间的转换。
```C++
// set 与 vector 之间的互相转换
#include <vector>
#include <unordered_set>

int main() {
    std::vector<int> vec {1, 2, 3, 4};
    std::unordered_set<int> set(vec.begin(), vec.end());
    vec = std::vector<int>(set.begin(), set.end());
}
```

```C++
// map 转换为 vector
#include <string>
#include <map>
#include <vector>
#include <algorithm>

int main()
{
    std::map<std::string, int> map;
    std::vector<int> vec;

    map["one"] = 1;
    map["two"] = 2;
    map["three"] = 3;
    map["four"] = 4;
    map["five"] = 5;

    // 用于对范围内的元素进行变换，并将结果存储到另一个范围。
    std::transform( 
        map.begin(), 
        map.end(),
        std::back_inserter(vec),        // 需要使用back_inserter，它会自动为vector分配空间
        [](auto &kv){ return kv.first;} // 返回输入迭代器的key，需要c++14
    );
}

// 注意这种写法, 上面的 back_inserter 是未分配空间，能够自动扩充, 接下来的是分配了空间
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec1 {1, 2, 3, 4, 5};
    std::vector<int> vec2 {1, 2, 3, 4, 5};
    std::vector<int> result(vec1.size());

    std::transform(vec1.begin(), vec1.end(), vec2.begin(), result.begin(), [](int x, int y) { return x + y; });

    for (int i : result) {
        std::cout << i << " ";
    }

    return 0;
}
```

#### 快乐数
* 要注意审题，题目中说了，如果其是快乐数，最后的各个位平方之和为 1，否则会无限循环。注意这个无限循环，其意味着如果不是快乐数，各个位平方之和的结果会循环出现。
* 这道题目就只能用 set 系列来做，因为不满足有限、尽可能连续的数组应用规则。
* 给一个正整数，取各个位上的数字的方法：
```C++
// 这里加了对负数挑选其各个位的方法，从低位到高位，就是很好拿出来呢
std::vector<int> getNum(int n)
{
    // 这里得到的结果是从低位到高位
    std::vector<int> result;
    bool isNegative = n < 0;
    n = std::abs(n);
    
    while(n){
        result.push_back(n % 10);
        n /= 10;
    }

    // 如果是负数，处理特殊情况
    if (isNegative && !result.empty()) {
        result.back() *= -1; // 把最后一位变成负数
    }

    return result;
}
```

#### 两数之和
* 首先应该想到的是，用一个循环遍历每个元素，能够知道其中一个数是多少，但是需要查找数组中是否有另一个数, 所以想到了用哈希表。
* 但是不能直接把数组转换为 set，因为这样可能会有重复元素，未说明数组中元素不能重复。
* 所以可以先逐个遍历，将遍历过的数字加入到集合中，即使有重复也不怕，因为是选两个元素，当前遍历到的就是第一个。
* 所以使用 std::unordered_map 即可，注意这里需要 key 存储数组值，value 存储索引下标（因为要找到这两个数的索引下标）。

#### 三数之和
* 通常来说，返回数组元素的内容的组合，而不是数组下标的组合，一般都是需要先排序的，然后再来做。
* 这道题目让返回的是元素内容，我们想到用双指针的方法。
* 首先对数据进行排序(从小到大)，然后利用一个 for 循环从左向右遍历，确定一个元素i（这个元素一定出现在数组中）
* left = i+1, right=size()-1, 如果 A[i] + A[left] + A[right] < target, 那就 left++; 如果 > , 就 right--; 不断重复循环，直到 left >= right
* 以上是遍历所有的组合，但是返回的结果要去重。对于 i 这个最小值的去重，`if(i>0 && nums[i]==nums[i-1]) continue;`。对于 left 和 right 的去重，是在每次添加完元素之后，`while (right > left && nums[right] == nums[right - 1]) right--;` 和 ` while (right > left && nums[left] == nums[left + 1]) left++;`;
* 还有一种利用 set 容器来去重的操作，代码如下所示
```C++
/*
    set::set 是基于红黑树（或其他平衡二叉搜索树）实现的有序容器。
    它使用元素类型的 < 运算符（或者自定义的比较函数）来维护元素的有序性和唯一性。
    因此，只要元素类型支持 < 运算符，std::set 就可以直接使用。
    std::vector<> 和 std::array<> 均重载了 operator< 就是逐个比较其中元素的大小

    是基于哈希表实现的无序容器。它依赖于元素类型的哈希函数和相等比较函数来确保元素的唯一性和查找的高效性。
    标准库中并没有为 std::vector<int> 提供默认的哈希函数和相等比较函数，因此我们需要自己提供这些函数。
*/
#include <iostream>
#include <vector>
#include <array>
#include <algorithm>
#include <set>
#include <unordered_set>

int main() {
    // 示例数据
    std::vector<std::array<int, 3>> vec = {
        {1, 2, 3},
        {4, 5, 6},
        {1, 2, 3}, // 重复元素
        {3, 2, 1}, // 重复元素
        {7, 8, 9},
        {4, 4, 6}  // 重复元素
    };

    // 使用 std::set 去重
    std::set<std::array<int, 3>> s(vec.begin(), vec.end());
    vec.assign(s.begin(), s.end());

    // 输出去重后的结果
    for (const auto& arr : vec) {
        std::cout << "{" << arr[0] << ", " << arr[1] << ", " << arr[2] << "}\n";
    }

    return 0;
}
```
* 两数之和那道题目，要求返回的是索引，所以不能直接使用这种双指针的方法，不然第一步一排序，就直接乱套了。

#### 四数之和
* 这道题目其实和三数之和是同一个道理，本来应该是 O(n^4) 的时间复杂度，通过双指针的方法降低成为了 O(n^3)
* 三数之和是先利用一个 for 循环确定一个最小的值，而四数之和就是先利用两个 for 循环来确定两个最小的值，然后再利用 left 和 right 进行一个遍历
* 注意这里也有去重的操作，与三数之和是一样的道理。i 是去重后的 i, k=i+1 开始，在对 k 去重。然后 left = k+1, right = size()-1;
* 总结一下的话，从三数之和和四数之和来看，每个索引都要去重，只不过 left 和 right 是在结果加入完之后再去重。

#### 四数相加
* 注意题目问的是有多少个？我们只需要统计次数就可以了。
* 将四个数组分成两组，A 和 B 一组，先计算这两个数组能够相加出来的和，并存入 map 中, key 是相加的和, value 是出现的次数。
* 再遍历 B 和 C，寻找其相加的和，如果能在 上一个 map 中找到相反数，就加一次 value 的值。
* 这样两两归类，就将时间复杂度从 O(n^4) 降低到了 O(n^2)。

### 字符串
#### 字符串反转
* 对于字符串反转、数组反转，其实写法都是一样的，都是用双指针的方法，`left=0, right=size()-1`, 循环条件是 `while(left<right)`, 注意交换写法，直接使用 `std::swap()`
* 对于链表的反转，也是利用双指针的方法，不过是直接改变指针的指向。
* 但是要注意的是, 也要善于使用库函数, std::reverse 反转，能够方便地实现某个区间内的反转。

#### 替换数字
* 其实这道题目是一个向数组或者字符串中插入多个元素的问题，是使用双指针的方法。
* 先用一个指针指向扩容前的最后一个元素，再用一个指针指向扩容后的最后一个元素，指向扩容后的元素的指针不到起始位置的时候，不停止。
* 先判断指向扩容前的指针指向的索引或者元素内容，然后向扩容后的位置插入特定的元素。
* 这道题目与删除数组/串中指定的值（多次删除）有很多相似之处，那个也是双指针的做法。

#### 反转字符串里的单词
* 实现 `"  hello world!  " -> "world! hello"`, 去除字符串中多余的空格, 利用双指针的方法，去除字符串中的某个元素（慢指针指向空格时候, 快指针必须指向字符串才能往后更新）。
* 然后将整个字符串反转，直接使用库函数即可；最后再将其中的每个单词进行反转(一次for遍历，利用一个变量记录上次单词开始的位置)
* 注意这种先整体大反转，再局部分块小反转的方法，是非常有用的。
* 右循环移动字符串/数组，将字符串/数组整体向右循环移动 n 位。其实整体思路就是将其分成两个部分，后n位和起始到后n位之前的部分。先将整个字符串颠倒，然后再将这两个位置分别颠倒。

#### KMP 算法
* KMP的经典思想就是：当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。
* 其实除了字符串，数组也是一样的。抽象来说，就是对一个主串，寻找第一次出现模式串的位置。
* next 数组就是一个前缀表，前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。
* 时间复杂度 O(n+m), 空间复杂度 O(m)[因为需要保存needle的前缀表]

```C++
void getNext(std::vector<int>& next, const std::string& s){
    int j=-1;
    next[0] = j;

    for(int i=1; i<s.size(); ++i)
    {
        while(j>=0 && s[j+1]!=s[i])
        {
            j=next[j];
        }

        if(s[j+1]==s[i])  // 只有相等的时候才 ++j
        {
            ++j;
        }

        next[i]=j;  // 要保证每个 next 都有值
    }
}

int getIdx(const std::string& str, const std::string& needle)
{
    if(needle.size()==0) return 0;  // 搜索空字符串时, 返回 0, 特殊规定

    std::vector<int> next(needle.size());  // 核心是 next 数组, j 是最长相等前后缀的值, next[j] 是前 j 个字符中最长相等前后缀的值
    getNext(next, needle);

    int j=-1;  // 因为下面比较了 needle [j+1] 和 str[i], 所以 j 是从 -1 开始的
    for(int i=0; i<str.size(); ++i)
    {
        while(j>=0 && needle[j+1]!=str[i])
        {
            j=next[j];
        }

        // j 在这里也是统计着最长相等前后缀的值 
        if (needle[j + 1] == str[i]) {  // 只有相等才 ++
            ++j;
        }

        if(j==needle.size()-1)
        {
            return i-j;
        }
    }

    return -1;
}
```

#### 重复的子字符串
* 这道题目其实没有什么技巧，只是能不能想到这种方法。
* 将两个子串s拼接到一起(t=s+s)，然后删除掉t的第一个元素和删除掉最后一个元素。在剩余串中寻找是否还能出现 s，若能出现则是由重复的串构成的。
* 这里的 KMP 算法就直接使用 `find` 函数就可以了。
* 要是数组的话，可以先转为字符串在进行操作，或者直接使用 KMP 算法进行寻找。

### 栈与队列
* 栈是先进后出，C++中是 `std::stack<>`, 队列是先进先出，C++ 中是 `std::queue<>`。栈和队列在 C++ 中都是容器适配器，其底层容器是 `std::queue<>`, `std::vector<>` 或 `std::list<>` (其实 C++ 中的栈和队列要求的是底层容器能够提供那些函数，如果自定义的类包含这些函数，那也可以使用自定义的)。
* 栈里面的元素在内存中是连续分布的么？
    - 陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。
    - 陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。

#### 用栈实现队列
* 要用两个栈来实现队列，一个输入栈，一个输出栈。输入栈负责队列的 push 操作，输出栈负责队列的 pop 操作。
* 在队列 push 的时候，将数据都放入到输入栈就行；在队列 pop 的时候，如果输出栈为空，就把输入栈数据全部导入进输出栈，再从输出栈弹出数据。
* 如果输入栈和输出栈都为空的时候，队列就为空。

#### 用单向队列实现栈
* 使用两个单向队列，一个做为输入队列，一个做为输出队列，其实是没有作用的，因为并不会颠倒元素顺序。
* 其实只需要使用一个单向队列就能实现栈，在栈 push 的时候，直接将元素 push 进队列就行; 在栈 pop 的时候, 将除了最后一个元素全都 pop 出去，然后依次加入到队列末尾。此时再 pop，就得到了最后加入的元素。
* 当单向队列为空的时候，栈就空了。

#### 括号匹配(栈)
* 由于栈的结构，使其非常适合做`对称匹配`的问题。
* 依次编列输入的括号字符串，如果当前的字符是`(`，`[`等左括号，就将其需要匹配的右括号`)`, `]`加入栈中；如果当前字符是右括号`]`，`)`, 就判断栈是否为空，如果为空就匹配失败，如果不为空，但是栈顶元素不等于当前字符也匹配失败。遍历完所有字符后，如果栈不为空，仍然匹配失败。

#### 删除字符串中重复的元素(栈)
* 这个也是匹配问题，通过遍历当前元素来前一个元素是否与当前遍历的元素相同。
* 这里如果用栈做为中间存储的话，最后要记得颠倒下字符元素，最简洁的方法是直接用存储字符串的结果来当作栈使用。

#### 逆波兰表达式(栈)
* 逆波兰表达式是一种后缀表达式(运算符写在后面), 比如平时正常的中缀表达式是 (1+2)*(3+4) 变成后缀表达式后为 `12+34+*`, 逆波兰表达式其实是用后序遍历的方式把二叉树序列化。
* 逆波兰表达式的优点是，去掉括号表达式无歧义，使用用栈操作运算（遇到数字则入栈，遇到运算符去除栈顶两个元素进行计算，并将结果压入栈中）。
* 逆波兰表达式求值的整体思路是：遇到数字则入栈; 遇到运算符去除栈顶两个元素进行计算，并将结果压入栈中; 最终表达式是值就是栈里的最后一个元素。

#### 滑动窗口最大值(单调队列)
* 其实就是要求，能够找到最大的元素，而且还能够删除指定的元素。
* 如果使用优先队列(大顶堆) `priority_queue`，能够每次找到最大的元素，但是并不能删除指定的元素。
* 所以这里可以使用自建的单调队列，也可以使用 `multiset`，这个是满足这个性质的，而且元素能够重复。
* 注意这里实现滑动窗口的代码逻辑。逐一遍历数组中的元素，当加入前 k-1 个时候，只有向 `multiset` 中插入的操作；当插入完前k个元素后，以后每次都要将 set 中的最大值保存到数组中（利用 `rbegin()`, 因为默认是从小到达排序）, 从第 k+1 个元素开始，就每次都是删除一个指定元素(i-k)，添加一个指定元素。
* 这里也给我们提了个醒，对于变化的元素进行排序的时候，可以使用红黑树的 `set` 来帮助我们。

#### 前 k 个高频元素(优先队列)
* 这里主要分成三个步骤，先用 map 统计每个元素出现的频率；然后依据频率进行排序；最后找出前 K 个最高频的元素。
* 因为 C++ 中的 map 通常只能依据 key 的值来进行排序，所以这里利用优先队列(小顶堆)来进行排序，即队列元素小于k的时候，就一直将map元素往里扔。当时队列元素等于k的时候，每次压入元素前，先把最小的给剔除。
* 最后将优先队列中的k个元素逐个pop()出去，然后依序加入到 vector 中，就是从大到小的结果。
```C++
// 小顶堆
class mycomparison {
public:
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};

// 对频率排序
// 定义一个小顶堆，大小为k
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
```
* 其实还有其他方法实现对 map 中元素的排序；首先仍然是先使用 map 统计各个词出现的频率；然后定义一个 set, 自定义排序顺序，将 map 中的元素都加入到 set 中。

#### 单调栈
* 单调栈通常用于一维数组，要寻找任一元素的右边或者左边第一个比自己大或者小的元素的位置，时间复杂度为 `O(n)`, 单调栈的本质也是空间换时间。
* 单调栈中存储的是数组下标，在从头向后遍历数组的时候，如果要找到每个元素最右侧第一个大于自己的数组下标，就应该让单调栈从栈头到栈底是单调递增的。
* 如果要找每个最右侧第一个小于自己的数组下标，就应该让单调栈从栈头到栈底是单调递减的(同理，如果要是最左侧，就是换个方向，从尾向头遍历)。
* 需要注意的事项：
    - 栈首先要将第一个元素压入栈中，因为接下来的逻辑是一直要与栈头元素所代表的值判断。
    - 每遍历到一个元素，就要将这个元素在数组中代表的值与栈头的元素所代表的值进行对比(基本上就两种操作，直接压入栈或者先弹出一些元素，再直接压入栈)。
    - 一定要注意默认的结果是多少，数组就初始化为多少。

```C++
// 版本一
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        // 递增栈
        stack<int> st;
        vector<int> result(T.size(), 0);
        st.push(0);
        for (int i = 1; i < T.size(); i++) {
            if (T[i] < T[st.top()]) {                       // 情况一
                st.push(i);
            } else if (T[i] == T[st.top()]) {               // 情况二
                st.push(i);
            } else {
                while (!st.empty() && T[i] > T[st.top()]) { // 情况三
                    result[st.top()] = i - st.top();
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

* 下一个更大元素(寻找部分元素的下一个最大元素)
    - 这道题目中注意，一说到无重复元素就要想到，1）可以进行先排序，再做其他运算 2）可以将 value 做为 map 的key, 而数组索引做为 map 的值。
    - 当要知道数组 nums2 中的元素是否在 nums1 中出现过时，就要想到要用 set/map 进行映射, set 能够知道是否出现过，map 还能知道具体出现在 nums1 中的哪里(要保证 nums1 是不重复的，利用 value-index 来创建 map)。
    - 这道题目也是有些默认值的，题目中说了，默认值填写为 -1 就可以了，所以初始化 result 数组时候，使用 -1 来填充就可以了。

* 循环下一个最大元素
    - 这道题目最简单的方法，其实是将数组num重复一遍，拼成一个新的数组，然后再利用单调栈就可以解决了。
    - 另一种方法需要好好掌握，其实也就是循环遍历的方法。
    ```C++
    for(int i=0; i<2*nums.size(); ++i)  // for 循环控制循环的次数
    {   // id 依次取值为 0, 1, ..., nums.size()-1, 0, 1, ... , nums.size()-1
        int idx = i % nums.size();  // 接下来就是一直使用 idx 了
    }
    ```

* 接雨水
    - 这道题目有两种计算方法，逐行计算和逐列计算。逐列计算是动态规划+直接计算的方法，逐行计算是单调栈的方法。
    - 对于逐行计算，需要记录每个柱子左侧柱子(包含当前柱子)的最高高度和右侧柱子(包含当前柱子)的最高高度。遍历每个柱子，`当前列雨水面积=(min(左边柱子的最高高度, 右边柱子的最高高度)-当前柱子的最高高度)*1`。
    - 分别使用 maxRight 和 maxLeft 来动态规划记录最左侧和最右侧柱子的最大高度。`maxLeft[i]` 表示包含柱子 i 左侧柱子的最大高度，动规公式为 `maxLeft[i]=std::max(height[i], maxLeft[i-1])`。
    ```C++
    class Solution {
    public:
        int trap(vector<int>& height) {
            if (height.size() <= 2) return 0;

            // 动规数组
            vector<int> maxLeft(height.size(), 0);
            vector<int> maxRight(height.size(), 0);
            int size = maxRight.size();

            // 记录每个柱子左边柱子最大高度
            maxLeft[0] = height[0];
            for (int i = 1; i < size; i++) {
                maxLeft[i] = max(height[i], maxLeft[i - 1]);
            }
            // 记录每个柱子右边柱子最大高度
            maxRight[size - 1] = height[size - 1];
            for (int i = size - 2; i >= 0; i--) {
                maxRight[i] = max(height[i], maxRight[i + 1]);
            }

            // 求和, 一个柱子一个柱子的遍历，从头遍历到结尾
            int sum = 0;
            for (int i = 0; i < size; i++) {
                int count = min(maxLeft[i], maxRight[i]) - height[i];
                if (count > 0) sum += count;  // 这里要加个判断，并不是每个柱子都能有积水的
            }

            return sum;
        }
    };
    ```
    - 对于逐行计算，确定是从左往右遍历(因为要找每个元素最右侧的元素), 栈头到栈尾是递增的（要找大于的）。
    - 注意一点是，当前遍历的元素大于栈顶元素，则出现了凹槽，其中一个边是栈顶的里面的哪一个元素，第二个边就是当前的元素。
    - 可知雨水的高度为 `min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度`, 雨水的宽度为 `凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度）`, 雨水面积为 `h*w`。
    - 注意这里两边的是如何处理的。
    ```C++
    class Solution {
    public:
        int trap(vector<int>& height) {
            if (height.size() <= 2) return 0; // 可以不加

            stack<int> st;
            st.push(0);
            int sum = 0;
            for (int i = 1; i < height.size(); i++) {
                while (!st.empty() && height[i] > height[st.top()]) {
                    int mid = st.top();
                    st.pop();
                    if (!st.empty()) {
                        int h = min(height[st.top()], height[i]) - height[mid];
                        int w = i - st.top() - 1;
                        sum += h * w;
                    }
                }
                st.push(i);
            }
            return sum;
        }
    };
    ```

* 柱状图中的最大矩形面积
    - 本题是寻找栈顶和栈顶的下一个元素以及要入栈的三个元素组成我们要求最大面积的高度和宽度。
    - 要注意边界条件，1）元素个数不够的时候 2）元素均为升序的时候 3）元素均为降序的时候
    ```C++
    class Solution {
    public:
        int largestRectangleArea(vector<int>& heights) {
            stack<int> st;
            heights.insert(heights.begin(), 0); // 数组头部加入元素0(防止为单减的时候得不到 left)
            heights.push_back(0); // 数组尾部加入元素0(防止为单增的时候，不进入while)
            st.push(0);
            int result = 0;
            for (int i = 1; i < heights.size(); i++) {
                while (heights[i] < heights[st.top()]) {
                    int mid = st.top();
                    st.pop();
                    int w = i - st.top() - 1;
                    int h = heights[mid];
                    result = max(result, w * h);
                }
                st.push(i);
            }
            return result;
        }
    };
    ```

### 二叉树
* 常用的二叉树的两种主要形式：满二叉树和完全二叉树。满二叉树：深度为k(只有一个节点的二叉树，深度为1), 有 $2^k-1$ 个节点的二叉树(第 k 层的节点个数为 $2^{k-1}$)；完全二叉树：在完全二叉树中，除了最底层的节点可能没有填满以外，其余每层的节点数都达到最大值，其最下面一层的节点都集中在该层最左边的若干位置(当h不是最后一个层时，这层节点数为 $2^{k-1}$, 否则为 1~$2^{k-1}$)。
* 有值得二叉树常用两种形式：二叉排序树和平衡二叉树。二叉排序树：若左子树不为空，则左子树所有节点的值均小于根节点的值；若右子树不为空，则右子树所有节点的值均大于根节点的值; 它的左、右子树也分别是二叉排序树；平衡二叉树：左右两个子树的高度差的绝对值不会超过 1, 并且左右两个子树都是平衡二叉树。
* 二叉树的存储方式：链式存储和顺序存储。链式存储就和链表类似，顺序存储就是用数组存储。
```C++
// 链式存储
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// 数组存储
// 根节点位于数组中下标为0的位置。父节点的数组下标时 i, 左孩子下标就是 2*i+1, 右孩子就是 2*i+2。
```

#### 二叉树的深度遍历(递归)
* 二叉树主要有深度优先遍历和广度优先遍历两种类型。其中深度优先遍历是先往深走，遇到叶子节点再往回走；广度优先遍历时一层一层的去遍历。深度优先遍历包括：前序遍历（递归法，迭代法），中序遍历（递归法，迭代法），后序遍历（递归法，迭代法）；广度优先遍历：层次遍历（迭代法）。
* 在写递归函数的时候，要注意三个点：函数参数和返回值（每层都返回什么）, 终止条件(不可能无限制递归下去), 单层递归的逻辑。
```C++
// 前序遍历
class Solution {
public:
    // 往深层里遍历，每遇到一个不为 nullptr 的，先将当前值加入到遍历结果中，然后再遍历其左侧和右侧的节点。
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == NULL) return;
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root, result);
        return result;
    }
};

// 中序遍历，先一股脑的向左侧扎下去（先左侧遍历到nullptr）
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    // 中
    traversal(cur->right, vec); // 右
}

// 后续遍历
void traversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    traversal(cur->left, vec);  // 左
    traversal(cur->right, vec); // 右
    vec.push_back(cur->val);    // 中
}
```

#### 二叉树的深度遍历(迭代)
* 对于迭代的方法，其实就是用栈模拟函数调用的过程(参考着递归的过程来写非迭代的方法)。前序遍历如下：
    - 先让头节点入栈。
    - 然后开始迭代，每次都是取出栈顶元素(这个是进入这个为头节点的函数), 然后先把右边的加进去(后递归这个)，再把左边的加进去。
    ```C++
    class Solution {
    public:
        vector<int> preorderTraversal(TreeNode* root) {
            stack<TreeNode*> st;
            vector<int> result;
            if (root == NULL) return result;
            st.push(root);
            while (!st.empty()) {
                TreeNode* node = st.top();                       // 中
                st.pop();
                result.push_back(node->val);
                if (node->right) st.push(node->right);           // 右（空节点不入栈）
                if (node->left) st.push(node->left);             // 左（空节点不入栈）
            }
            return result;
        }
    };
    ````
* 中序遍历的方法其实也不难，就是要对比递归来做：
    - 总体思路就是直接进入新的节点，就一直往左遍历，直到为 nullptr;
    - 当为 nullptr 时，退一个，即取出栈顶元素，然后将其遍历，将其右侧加入到栈中
    ```C++
    class Solution {
    public:
        vector<int> inorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            TreeNode* cur = root;
            while (cur != NULL || !st.empty()) {
                if (cur != NULL) {  // 不为 nullptr，就往左遍历
                    st.push(cur);
                    cur = cur->left;                // 左
                } else {
                    cur = st.top(); // 从栈里弹出的数据, 其实这个相当于是递归中回退了一次
                    st.pop();
                    result.push_back(cur->val);     // 中
                    cur = cur->right;               // 右
                }
            }
            return result;
        }
    };
    ```
* 后序遍历比中序遍历还要更多考虑一些，因为遍历完左的，回退一步，并不弹出，而是转头遍历右侧的，所以需要 prev 来记录下（prev 记录的上一个已经被遍历了右子树的节点）。最后 cur = nullptr 是已经知道了没有左侧的节点了。
    ```C++
    class Solution {
    public:
        vector<int> postorderTraversal(TreeNode* root) {
            vector<int> result;
            stack<TreeNode*> st;
            TreeNode* cur = root;
            TreeNode* prev = nullptr;
            while (cur != NULL || !st.empty()) {
                if (cur != NULL) {  // 不为 nullptr，就往左遍历
                    st.push(cur);
                    cur = cur->left;                // 左
                } else {
                    cur = st.top(); // 从栈里弹出的数据, 其实这个相当于是递归中回退了一次
                    if(cur->right && cur->right!=prev){  // 右节点不为 nullptr, 且右节点未被访问过
                        cur = cur->right;
                    }else{
                        st.pop();
                        result.push_back(cur->val);     // 中
                        prev = cur;
                        cur = nullptr;  // 因为 cur 的 left 肯定是没有了，right 进到 else 里也是没了或者被访问过
                    }
                }
            }
            return result;
        }
    };
    ```

#### 二叉树的广度优先遍历(层序)
* 二叉树的层序遍历就是广度优先遍历的一种特殊形式，一层一层的遍历，这一层连接到下一层的桥梁就是节点的左右节点, 需要注意的一点就是，每层的数量是固定的，不要单纯使用变化的 `que.size()`。
```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```

#### 翻转二叉树
* 其实就是考察二叉树的遍历，只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果, 可以直接使用前向遍历递归法, 也是简单的。
```C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        // 就是注意是接下来的反转左右，其实是反转原始的右左子树
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
};
```

#### 对称二叉树
* 二叉树的方法用递归来解决的话，一般都是先将问题转换为一个递归的问题(同样的问题，但是规模更小了)。这道题其实是比较两个子树(A和B)的问题，A和B对称 转换为 A 的左节点和B的右节点是否对称，A的右节点和B的左节点是否对称。递归终止条件一般都与 nullptr 有关。
* 可以使用层序遍历的方法，使用一个队列同时遍历两个二叉树，这里需要注意的就是两两一组。

#### 二叉树的最大深度
* 二叉树的深度是指根节点是最小的(为0或者为1需要依照题目条件), 二叉树的高度是指从最远的节点开始的高度，根节点的高度是最高的。
* 求深度非常适合用层序遍历，求高度很适合用后序遍历（先求左子树和右子树的高度，再用最大值+1就是当前的高度）。
* 求深度也能用前序遍历，这是一个回溯的方法。
* 这道题目求最大深度，其实也就是求树的高度。求深度：前序+回溯方法，层序遍历的方法。求高度：后序遍历的方法。
* 也能当成一个整体去理解，转换为更小的问题来处理，已知左右子树的最大深度，加上当前节点的最大深度是多少？

#### 二叉树的最小深度
* 求最小深度，用层序遍历的方法很好做，找第一个左右均为 nullptr 的节点，记录它在多少层，深度就是多少。
* 递归的话，转化成更小的问题，已经左右子树的最小深度是多少，加上当前节点最小深度是多少？(与最大深度不同的点，要注意有一侧没有节点的情况)
* 一侧没有节点，其实是最大深度也应该考虑的，不过哪里的 std::max() 掩盖了这个问题。

#### 求二叉树的节点个数
* 求二叉树的节点个数，用层序遍历的话，是非常好做的，记录每层的节点个数，然后加在一起。
* 用递归的方法也是很好做，当前节点二叉树的节点个数= 左子树二叉树节点个数+右子树二叉树节点个数+1；

#### 平衡二叉树
* 这道题目其实是变相考察求二叉树的高度，求二叉树的高度就用后序遍历。
* 这题有个技巧，就是函数返回值是 int, 当是平衡二叉树的时候，就正常返回高度，否则就返回特殊标志 -1, 告知不是平衡二叉树。

#### 二叉树的所有路径
* 这道题目本质上是回溯的写法，这个回溯有技巧的地方，是其将结果利用引用的写法 `&`, 最后满足条件了，再存储到 result 中。
* 而回溯的路径部分，使用了普通的赋值语法，这样就实现了回溯的写法，非常巧妙可以好好看一看。

#### 左子树之和
* 仍然是用递归的方法，当前节点的左子节点之和=左子树的左子节点之和+右子树的左子节点之和（但是要注意左子树就是左子节点的情况）。
* 判断是一个节点是不是左子节点，只知道这个节点是不够的，要知道其父节点才行。如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子。

#### 找左下角的值
* 这道题目不太能使用普通将大问题拆成小规模的子问题，而是使用深度优先遍历的方法，每次优先左遍历，当取得最大深度的时候，记录下这个节点。
```C++
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) {
        if (root->left == NULL && root->right == NULL) {
            if (depth > maxDepth) {  // 这里很有技巧，只记录第一取得最大值得时候
                maxDepth = depth;
                result = root->val;
            }
            return;
        }
        if (root->left) {
            traversal(root->left, depth + 1); // 隐藏着回溯
        }
        if (root->right) {
            traversal(root->right, depth + 1); // 隐藏着回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```
* 本题使用层序遍历的话，是非常好解决的。

#### 路径总和
* 利用回溯的思想（深度优先搜索）, 遇到叶子节点判断是否是路径和。这道题目的技巧有两点，第一点就是不用累加而用类减，判断剩余路径是否是剩余的累加和。第二点就是返回值是 bool, 判断是否构成了。

#### 依据遍历顺序构造二叉树
* 前序和中序可以唯一确定一棵二叉树, 后序和中序可以唯一确定一棵二叉树, 前序和后序不能唯一确定一棵二叉树，因为没有中序遍历无法确定左右部分，也就是无法分割(必须有中序，其它随便加一个前序或者后序就可以唯一确定一棵二叉树)。
* 利用中序遍历和后序遍历构造二叉树：关键点主要有：
    - 不要真的传递数组，而是要传递中序的`[start, end)`, 传递后序的 `[start, end)`, 都是左开右闭的原则(因为是下一步都是在上一步的基础上进行分割，座椅可以这样做)。
    - 如果后序遍历 start==end, 直接返回 nullptr; 否则就取出后序遍历位于 end-1 处的元素，做为当前树的头节点；
    - 如果 end-start == 1 则说明只有一个节点，并没有子节点了，返回这个新建立的节点就可以了; 否则就先遍历中序数组，找到等于这个节点的值，从这里切分成左中序和右中序。
    - 对于后序的切分，是利用左后序的元素个数==左中序的元素个数, 右后序的元素个数==右中序的元素个数来实现的。
    - 最后就是递归 root-left = (); root-right = ();

* 利用前序和中序唯一确定一个二叉树: 与中序与后序一样，不过这次取的是前序中的第一个当作头节点。

#### 最大二叉树(构造二叉树)
* 这道题目仍然和上一道题目一样，确定一个值，然后分成左子树的部分和右子树的部分，这样递归下去，这道题目比上一道题目还要简单。
* 就是有个问题，不要总想着找最大值能不够优化下时间复杂度，先写出来是重要的, 这里遍历寻找最大值就可以了。
* 通过以上两种构造二叉树的方法，我们发现都是使用的是前序遍历，先确定头节点，然后再分割出左子树和右子树的区间。

#### 合并二叉树(利用两个二叉树构造二叉树的题目)
* 其实就是掌握同时遍历两棵二叉树的方法，其实当一个为 nullptr, 另一个不是的时候，就已经把这个节点及下面连接的所有子树都赋值过去了。

#### 二叉搜索树中的搜索
* 二叉搜索树是一个有序树，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；左右子树也分别为二叉搜索树。
* 二叉搜索树相比于普通的二叉树是有方向的去搜素，如果 root->val > val, 搜索左子树；如果 root->val < val, 搜索右子树。
* 迭代法在二叉搜索树中寻找值也非常好用(因为节点是有序的，方向都给确定好了，所以不用使用辅助栈或者队列)。

#### 验证二叉搜索树
* 验证二叉搜索树，要抓住 `验证二叉搜索树，就相当于变成了判断中序遍历的序列是否是递增`
* 最简单的方法，就是直接使用一个数组，保存中序遍历的结果，再使用一个 for 循环来逐一判断是不是递增的。 
* 时间复杂度 O(1) 的办法就是，就是在遍历过程中保留上一个遍历过的节点，然后与当前遍历的节点的值进行对比。
* 注意 左子树是二叉搜索树，右子树是二叉搜索树，当前节点的值大于左孩子的值，小于右孩子的值，所以也是二叉搜索树是错误的。
* 应该是当前节点的值大于左子树中最大的值，小于右子树中最小的值，当前树才是二叉搜索树。

#### 二叉搜索树中的最小差值
* 在遇到二叉搜素树中，求最值、差值之类的，把它想象成在一个有序数组中求最值，求差值(一定要好好利用二叉搜索树有序的特性)。

#### 二叉搜索树中的众数
* 从寻找二叉树最左下的的节点和这道题目中可以总结下：如果寻找第一次到达最大值的元素，可以使用 if(value>maxValue)；如果想要记录取得最大值的所有元素，可以使用 if(value==maxValue) vec.push_back(value)，if(value > maxValue) vec.clear(); vec.push_back(); 相当于每次重复最大值的时候都装入，但是更新最大值的时候就清空数组。

#### 二叉树的最近公共祖先
* 这道题目有两个假设，所有节点都是唯一的(要找的值，有且只有一个)，要找的两个节点一点是存在于二叉树中的(一定都能找到)。
* 这道题目的思路其实就是使用后序遍历，无论左右子树，只要找到了 p 或者 q 就往上返回，当左右子树有一个为 nullptr 时，返回不为 nullptr 那个，如果均不为 nullptr, 那就返回当前的节点。
```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == q || root == p || root == NULL) return root;  // 只要遇到就返回, 前提是就不重复
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != NULL && right != NULL) return root;

        if (left == NULL && right != NULL) return right;
        else if (left != NULL && right == NULL) return left;
        else  { //  (left == NULL && right == NULL)
            return NULL;
        }

    }
};
```

#### 二叉搜索树搜索最近公共祖先
* 要利用二叉搜索树的特性，当从上往下遍历的时候，第一次遇到 cur 节点是在数值 p 和 q 区间中时，那么 cur 就是 p 和 q 的公共祖先。
* 所以这道题目直接从头开始遍历就可以了，因为不需要回溯，可以一路 next。
* 递归法的思想也是很简单的，因为题目前提是一定能够找到且方向是一定正确的，所以代码直接这样写就可以了。注意这里的 if, else if，每次都是只往一个方向走，而不是普通二叉树两个方向都要寻找。
```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root->val > p->val && root->val > q->val) {
            return lowestCommonAncestor(root->left, p, q);
        } else if (root->val < p->val && root->val < q->val) {
            return lowestCommonAncestor(root->right, p, q);
        } else return root;
    }
};
```

#### 二叉搜索树插入操作(插入)
* 单纯的插入操作是非常简单的, 不涉及到结构的调整。整体思路就是，当前节点的值大于要插入的值，则向左子树插入节点（要更新下左子树）；当前节点的值小于要插入的值，向右子树插入节点（要更新下右子树）。如果当前节点为空，就创建节点，找到了插入的位置，插入其中。这里返回值是有很大的作用的，负责更新左子树和右子树。
* 这里的函数的意思是，返回以当前节点为头节点的子树中删除指定元素后的树的结构。

#### 二叉搜索树删除操作(删除)
* 二叉搜索树中删除指定的元素，就涉及到了调整二叉搜索树的结构问题。其实也是冷静下来思考就可以了，没有什么难度的。
* 其实也不是什么难得，把哪五种情况都列举了就可以了。
    - 第一种：没有找到删除的节点，遍历到空节点就返回。
    - 第二种：删除节点左右孩子都为空，直接删除即可。
    - 第三种：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点。
    - 第四种：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点。
    - 第五种：左右孩子节点都不为空，则将删除节点的（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

#### 二叉搜索树修剪操作(保留一个区间内的值，其余值全部删除)
* 这个于二叉搜索树中删除一个值还是不一样的，因为加入当前节点的值小于其保留的区间的左边界，所以当前节点所有左侧的都可以不要了，所以不会出现上一个题的那个5种情况。
* 整体思路应该是：当前节点的值如果小于区间的左边界，则修剪当前节点的右子树并返回;当前节点的值如果大于区间的右边界，则修剪当前节点的左子树并返回; 在这个中间的话，就分别再修剪这个节点的左子树和右子树分别返回。

#### 有序数组生成二叉搜索树(构建二叉搜索树)
* 这道题目其实比普通的构造二叉树要更简单(比那道构造最大二叉树简单，省去了排序的步骤)，因为分割点很好找。整体步骤仍然是(坚持左闭右开):
    - 如果 left>=right, 返回 nullptr; 否则用 mid(mid=(left+right-1)/2) 创建一个新节点；
    - 如果 right-left==1, 则返回这个新创建的节点；
    - 否则，将当前区间再分成两半，小的那半用于生成左节点，大的那半用于生成右节点；

#### 二叉搜索树转换为累加树
* 其实这道题目就是右左中的遍历方法，并将每次遍历的结果进行累加。

### 动态规划
* 动态规划中每一个状态一定是由上一个状态推导出来的。贪心算法是局部直接选最优的，和上一个状态没有关系。
* 动态规划的解题步骤是：1）确定 dp 数组及其下标的具体含义 2）确定递推公式 3）dp 数组如何初始化(那些进行初始化，这些初始化为多少) 4）确定遍历顺序(递推公式决定了遍历顺序, 遍历顺序决定了循环顺序。)

#### 爬楼梯(有多少种方法)
* 整体思想就是到第三层楼可以由第二层和第一层楼状态推导出来。
* dp[j] 表示爬到第 j 层楼梯，有 dp[j] 种走法。
* dp[j] = dp[j-1] + dp[j-2];

#### 使用最小的花费爬楼梯(代价最小)
* 整体思路就是第 j 层楼梯体力的最小花费是由到第 j-1 层楼梯所花费体力 dp[j-1] 加上花费 cost[j-1] 和 到第 j-2 层楼梯所花费体力 dp[j-2] 加上花费 cost[j-2] 的最小值。
* dp[j] 表示达到第 j 层楼梯所需要花费的最少体力。
* dp[j] = std::min(dp[j-1]+cost[j-1], dp[j-2]+cost[j-2])

#### 机器人不同路径条数（有多少种方法）
* 这道题目也是求有多少种走法，其实和爬楼梯的思想是一样的。就是将到达前几个状态的方法总数相加就可以了。
* dp[i][j] 表示从 (0, 0) 出发，到(i,j)有dp[i][j]条不同的路径。
* dp[i][j] = dp[i-1][j] + dp[i][j-1] (因为 dp[i][j] 只有这两个方向过来)
```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;  // 注意这个地方哈，是 1
        for (int j = 0; j < n; j++) dp[0][j] = 1;  // 注意这个地方哈，也是 1
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

#### 整数拆分
* 这道题目抽象出来就是，给定正整数 n(n>=2), 拆分成至少两个正整数之和，使这些正整数的乘积最大。
* 其实突然一想是很难的，但是动态规划有时候就能解决这种困难的问题。dp[j] 表示分拆正整数 j, 能够得到的最大乘积。因为我们能够假设 dp[2],....,dp[j-1] 已经求出来了，如何得到 dp[j]。可以利用 for 循环，dp[j] = max({dp[j], i*(j-i), i*dp[j-i]})。因为 dp[j-i] 是拆成2份及以上的，i×dp[j-i] 是拆成3份及以上的，那就是少了拆成2份的，i×(j-1).
* 其实 i 不需要从 1 到 j-1, 而只需要从 1 到 j/2, 因为"拆分一个数n使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的", 至少拆成2份，所以一定是遍历到 j/2 就可以了。

#### 不同的二叉搜索树
* 这道题目和上一个题目都是一个 dp 数组但是两个 for 循环，外层的 for 循环用来得到 dp[i] 的值，里层的 for 循环是用来确定两个状态 i 和 j-i, 搭配 dp[i], dp[j-i], 得出不一样的组合。注意一点就是里层 for 循环会得到多个 dp[i] 的值，这些值如何处理，也要考虑。

#### 零一背包问题
* 零一背包问题，其实抽象出来就是，背包容量有限，每个物品都有容量和价值，每个物品只能选一次，在不超过背包容量的情况下最多能够装下的最大价值。
* dp[j] 表示容量为 j 的背包，最大能够能够装下的价值。每个物品的价值，其实是可以由我们自己赋予，在一个限制的情况下，让这个自己赋予的价值最大。
* 其实我们可以发现，零一背包问题，一半都是自己将问题抽象出来，基本没有直接说自己的问题是0-1背包问题的。主要给关键词就是，不重复的选择(这个一般用别的方法都是很难的)，分成两份(一份是选择的，一份是剩下的)，求价值最大(当价值与质量相同时，就是看能否正好凑成，凑不成的话差多少的问题)。
```C++
// 一维dp数组实现
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 读取 M 和 N
    int M, N;
    cin >> M >> N;

    vector<int> costs(M);
    vector<int> values(M);

    for (int i = 0; i < M; i++) {
        cin >> costs[i];
    }
    for (int j = 0; j < M; j++) {
        cin >> values[j];
    }

    // 创建一个动态规划数组dp，初始值为0
    vector<int> dp(N + 1, 0);  // dp[0] 的价值肯定是 0, 因为每给任何空间

    // 外层循环遍历每个类型的研究材料(选择是否添加的元素一定是放在最外层的)
    for (int i = 0; i < M; ++i) {
        // 内层循环从 N 空间(最大空间)逐渐减少到当前研究材料所占空间(递减遍历是当前这个容量下，这个是加还是不加，只有一次。j >=costs[i], 是只有这些才有更新机会，不然总容量都放不下这个，肯定保持原样)
        for (int j = N; j >= costs[i]; --j) {
            // 考虑当前研究材料选择和不选择的情况，选择最大值
            dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }

    // 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值
    cout << dp[N] << endl;

    return 0;
}
```
##### 分割等和子集
* 将数组分成两个子集，使得两个子集的元素和相等 -> 转换为 0-1 背包问题就是，在重量限制的条件下，从数组中选一些数出来，最大为多少。
    - 背包重量为 sum/2;
    - 每个物品的重量和价值相等，这就会使得重量为 target 的背包能够装载的最大价值为 target。这样一转换就能够转换成是否能够选择一些元素得到目标值。
* dp[j] 容量为 j 的背包，最大能够装载的价值为多少。
```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;

        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        vector<int> dp(10001, 0);
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        // 也可以使用库函数一步求和
        // int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 == 1) return false;
        int target = sum / 2;

        for(int i=0; i<nums.size(); ++i)
        {
            for(int j=target; j>=nums[i]; --j)
            {
                dp[j] = std::max(dp[j], dp[j-nums[i]]+nums[i]);
            }
        }

        // 集合中的元素正好可以凑成总和target
        if (dp[target] == target) return true;
        return false;
    }
};
```

##### 最后一块石头的重量
* 这道题目仍然是从数组中选一些元素，然后分成两组，让两组的差值尽可能的小。不重复选元素，分成两组，这些都提示我们可以使用动态规划。
* 仍然是物品的重量与价值相等，所以 dp[sum/2] 就是在这个限制下，选择元素累加和的最大值。

##### 目标和（统计所有可能的结果）
* 这道题目其实也是从数组中不重复的选择元素，但是不是凑成目标和了，而是有多少种方法凑成目标和。
* dp[j] 此时表示填满 j 这么大容量的包，有 dp[j] 种方法。
* 注意 dp 初始化的时候，dp[0] 必须为 1, 否则结果都是 0
```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(S) > sum) return 0; // 此时没有方案
        if ((S + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (S + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];  // 这里写成 dp[j] = dp[j] + dp[j-nums[i]]
            }
        }
        return dp[bagSize];
    }
};
```

##### 一和零（一个价值，但是多个条件限制, 2个维度的背包）
* 在 0 和 1 的个数这两个维度的限制下，最大价值是多少？(这里将每个元素的价值视为 1)。但是也是零一背包问题，因为是无重复元素，价值最大。
* 这题有两个限制条件，那么dp为 dp[m][n] 表示为 dp[m][n] 最多 m 个 0 和 n 个 1 的最大子集的元素个数。
* 还有一点就是，当 value 为 1 的时候，最大价值，就变成了元素的最大个数
```C++
// 这里时3个循环
for (string str : strs) { // 遍历物品
    int oneNum = 0, zeroNum = 0;
    for (char c : str) {
        if (c == '0') zeroNum++;
        else oneNum++;
    }

    // 对两个限制条件都逆序遍历
    for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
        for (int j = n; j >= oneNum; j--) {
            dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1); // 同时减少的
        }
    }
}
```
#### 完全背包问题
* 是指每件物品都有无限个（也就是可以放入背包多次）, 求解将那些物品装入背包，物品总价值最大。完全背包只是物品的个数是无限的，其余的是和零一背包一样的，都是有条件限制的。其代码模板如下：
```C++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);  // 这样就是能够使用多次
    }
}
```

#### 零钱兑换(方法数)
* 这道题目可以转换为背包问题，硬币可以重复使用，凑成总金额的组合数。但是有个问题是，对于多重背包问题，遍历顺序的不同会影响计算方法数时是组合数，还是排列数。
```C++
// 先遍历物品，对于某个容量，只会出现 {1, 5} 这种情况
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}

// 先遍历背包容量，再遍历物品，背包每个容量值都经过 1 和 5 的计算，{1， 5} 和 {5， 1} 两种情况
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

##### 组合总和(方法数)
* 可以从数组中重复选取，容量是目标和，每个元素的价值就是元素的数值。这道题目是找出元素的组合个数（不同顺序的视为不同的组合）。
* 这道题目其实很重要的一点是，求组合总数或者方法数就能反应能不能凑成目标和(方法数为0, 就不能凑成)。

##### 进阶版爬楼梯(方法数)
* 其实抽象来看，也是从一个数组种选取元素，其和到达目标值，有多少方法数。
* dp[i] 表示爬到有 i 个台阶的楼顶，有 dp[i] 种方法。

##### 零钱兑换(方法数，但是要求组合中的元素个数最少)
* 也是完全背包问题，只是需要修改下 dp 数组的定义和迭代公式。
* dp[j] 表示凑足总额为j所需钱币的最少个数为dp[j]。那么 dp[j]=min(dp[j - coins[i]] + 1, dp[j]); 外循环是硬币，内循环是容量，因为是找组合最少的元素个数，所以排列或者组合都没影响。
* 从这题可以看出，要找组合最大元素个数，也好找了。

### 图论
* 图的构造方法有邻接矩阵、邻接表的方法。邻接矩阵的方法是从节点的角度来出发的，使用二维数组来表示图结构。grid[2][5] = 6, 有向图，表示节点2 指向 节点5，边的权值为6。grid[2][5]=6, gird[5][2]=6, 无向图，表示节点2 与 节点5 相互连通，权值为6。
* 邻接表的方法，使用数组+链表的方式。邻接表是从边的角度出发的，有多少条边就会申请对应大小的链表
* 邻接矩阵的优点：检查任意两个顶点是否存在边非常快，适合稠密图(边数接近顶点平数平方图中)  缺点：稀疏图会导致申请过大的二维数组造成资源的浪费，遍历边的时候，要遍历整个 n*n 矩阵，时间浪费。
* 邻接表的优点：对于稀疏图，只需要存储边，空间利用率高；缺点：检查两个点的是否存在边效率较低

##### 深度优先搜索(dfs)
* 深度优先搜索是可着一个方向去搜索，直到遇到绝境(终止条件), 再换方向搜索(涉及到了回溯)。
* 代码框架如下
```C++
void dfs(参数) {
    if (终止条件)  // 通常时到达目标或者搜过了访问过的点
    {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```

##### 拓扑排序
* 给出一个有向图，把这个有向图转换成线性的排序，就叫做拓扑排序(拓扑排序也能检测这个有向图是否是有环，存在环的话不能做线性排序), 其也是图论中判断有向无环图的常用方法。
* 