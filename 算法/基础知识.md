## 数据结构基础套路
### 概述
1. 好算法的本质？
* 正确性。算法应该能够正确地解决求解问题。
* 可读性。算法应该具备良好的可读性，以帮助人们理解。
* 健壮性。输入非法数据时，算法能够适当地做出反应或者进行处理，而不会产生莫名奇妙的输出结果。
* 低的时间复杂度和低的空间复杂度。

2. 算法效率的度量？
* 时间复杂度：事前预估算法时间开销`T(n)`与问题规模`n`的关系。
    - 加法规则：`T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))`
    - 乘法规则：`T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))`
    - 顺序执行的代码只会影响常数项，可以忽略；只需要找循环中的一个基本操作，分析它的执行次数与n的关系即可；如果有多层嵌套循环，只需要关注最深层循环循环了几次。
    - 时间复杂度有最好时间复杂度、最坏时间复杂度、平均时间复杂度。主要关注最坏和平均时间复杂度。
* 空间复杂度：空间开销（内存开销）与问题规模`n`之间的关系。
    - 加法规则：`T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))`
    - 空间复杂度主要是与`数组的大小`和`递归调用的深度`有关。

### 数组
数组是存放在连续内存空间上的相同类型数据的集合, 可以通过下标索引的方式获取得到下标对应的数据；因为数组在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址；C++中二维数组是连续分布的。

#### 二分查找
1. 使用二分法的前提条件：1）数组有序 2）数组中无重复元素
2. 二分法的实现的注意事项：1）定义区间 [left, right]（左闭右闭） 2）循环条件(left<=right) 3）middle=left + (right-left)/2, 防止 left+right 溢出 3）通过判断 nums[middle] 与 target 的关系来决定更新 right, 还是 left, 还是直接返回 middle。4）注意更新的是 middle-1 和 middle+1, 而不是 middle。
3. 时间复杂度 `O(logn)`, 空间复杂度 O(1)。

#### 删除数组中元素 val
1. 整体思路就是, 将所有不等于 val 的值都移到数组前面, 记录非 val 值的个数, 然后直接 resize。
2. 这个题可以使用双指针的方法：1）快指针：遍历新元素，保存新元素的索引 2）慢指针：更新数组的下标的位置(这个起始也就代表了元素的个数)
3. 快指针一直向前遍历所有元素，如果快指针指向的元素不等于 val, 就更新到慢指针指向的位置，慢指针+1；如果快指针指向的元素等于 val，不更新到满指针指向的元素

#### 滑动窗口
滑动窗口是不断地调整子序列的起始位置和终止位置，从而得到我们想要的结果。
1. 滑动窗口本该是用两个 for 循环来做(一个起始位置，一个终止位置，时间复杂度为 O(n^2))
2. 而利用双指针法，利用一个 for 来遍历起始/终止位置, 再用一个指针来自动调节窗口的终止/起始位置。
3. 指针如何移动呢？主要考虑题目条件, 连续累加和超过？（移动一个元素）, 有些题目也有可能移动到快指针的位置
4. 注意这里的`双指针要都包含边界`, 所以得出个数的时候要 终止位置索引-起始位置索引+1。

#### 螺旋矩阵
这道题目，主要核心点就在于以下几点：1）确定需要循环的次数 n/2，n 为奇数的时候需要手动填充中间的值 2）每次循环开始的位置 3）每次循环开始的时候都确定 i 和 j
4）四个循环公用一套 i 和 j 5）填充的区间都是左闭右开，这样四个循环都是对称的。

### 链表
1. 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域，最后一个节点的指针域指向 `null`。链表分为单链表、双链表、循环链表。C++ 中链表的定义方式如下：
```C++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(nullptr) {}  // 节点的构造函数
};
```
2. C++中删除链表中某个节点：`A->B->C`(删除其中的 B 节点), 保存下 A 指向的下一个节点, 让 A 指向 C, 释放 A 指向的下一个节点。
3. C++中增添链表中某个节点：`A->C`(A->C 中增添 B), 保存 A 指向的下一个节点, 让 A 指向 B, 让 B 指向保存的 A 指向的下一个节点(C)。

#### 虚拟头节点
通常可以通过增加虚拟头节点的操作来使得对链表的操作进行统一。链表的一大问题就是操作当前节点必须要找前一个节点才能操作，因为头节点没有前一个节点了。
1. 添加和删除虚拟头节点的操作可以使得操作链表(插入，删除，索引)变得简单
```C++
ListNode* dummyHead = new ListNode(0);  // 设置虚拟头节点
dummyHead->next = head;  // 将虚拟头节点指向 head

// 返回新的头节点
head = dummyHead->next;
delete dummyHead;
return head;
```
#### 反转链表
1. 反转头节点不需要使用虚拟头节点。
2. 使用 `双指针的方法`。fast 指针初始化为头节点, slow 指针初始化为 nullptr。循环逻辑就是, 用 tmp 临时保存 fast->next, 然后 cur->next 指向 slow，更新 pre = cur, cur=tmp, 直到 cur == nullptr, 此时返回 链表头节点 pre。

#### 两两交换链表中的节点
1. 需要使用虚拟头节点。
2. 做链表的题目, 一定要把画图，用一组数据进行模型, 把每个步骤清楚的标注出来, 依据标注出来的结果来写代码。
3. 注意边界条件, 根据到结尾的第几个节点终止来确定循环的边界条件。本题是 `while(cur->next != nullptr && cur->next->next != nullptr)`。

#### 删除链表的倒数第 N 个节点
1. 需要使用虚拟头节点。
2. 使用双指针的逻辑, 快指针和慢指针都初始指向虚拟头节点。快指针先移动 N+1 步, 然后快慢指针一起移动, 直到快指针为 nullptr, 此时参数慢指针的next指向的节点。

#### 求链表长度的方法
1. 求链表长度时, 主要循环终止条件, 如下
```C++
int lenA = 0;
while(curA!=NULL){
    ++lenA;
    curA = curA->next;
}
```
2. 对于两个链表或者两个数组, 不能确定谁的元素多，谁的元素少时, 直接先判断长度, 然后用 `std::sawp` 进行交换, 保证想要的那个是元素多的。
```C++
curA = headA;
curB = headB;
// 让curA为最长链表的头，lenA为其长度
if (lenB > lenA) {
    swap (lenA, lenB);
    swap (curA, curB);
}
```

#### 判断链表是否有环, 并找到环的入口
1. 判断入口是否有环，使用快慢指针的方法, 这道题目不用虚拟头节点。
2. 快慢指针都从头指针出发，快指针每次移动2步，慢指针每次移动1步, 如果快指针等于慢指针, 则说明有环, 如果快指针检测到有 nullptr, 那就是无环。
3. 环的入口需要依据一个数学公式，从头节点到环的入口和从相遇点到环的入口，所走路程是相同的（前提仍然是 fast 每次走两步，slow 每次走一步依据这个公式来做）。

### 哈希表
哈希表是根据关键码的值而直接进行访问的数据结构，哈希表用来快速判断一个元素是否出现在集合中。哈希函数，通过hashCode把名字转化为数值，一般hashCode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。可以使用拉链法和线性探测法来解决哈希碰撞问题：
    * 拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间, 哈希表大小一定要合适，要映射尽可能的均匀。
    * 使用线性探测法，一定要保证 tableSize 大于 dataSize, 我们需要依靠哈希表中的空位来解决碰撞问题。
| 集合 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
|:----:|:-------:|:--------:|:---------------:|:------------:|:-------:|:--------:|
| std::set | 红黑树 | 有序 | 否 | 否 | O(log n) | O(log n) |
| std::multiset | 红黑树 | 有序 | 是 | 否 | O(log n) | O(log n)|
| std::unordered_set | 哈希表 | 无序 | 否 | 否 | O(1) | O(1) |

|映射	|底层实现|	是否有序|	数值是否可以重复|	能否更改数值|	查询效率|	增删效率|
|:----:|:-------:|:--------:|:---------------:|:------------:|:-------:|:--------:|
|std::map|	红黑树|	key有序|	key不可重复	|key不可修改	|O(logn)	|O(logn)|
|std::multimap|	红黑树|	key有序|	key可重复|	key不可修改|	O(log n)	|O(log n)|
|std::unordered_map| 哈希表|	key无序|	key不可重复|	key不可修改|	O(1)|	O(1)|

#### 有效的字符异位词
* 对于有限的、连续的、跨度小的哈希值，比如 26 个英文字母，可以直接映射到一个数组中，'a'映射到下标为0，'z'映射到下标为25；
* 这道题目是 3 个循环，第一个循环先统计其中一个字符串各个字符出现的次数并加1，第二个循环统计另一个字符串各个字符出现的次数并减1，最后一个循环用来判断各个元素是否为0
* 为什么遇到哈希问题不直接使用 unordered_set 系列容器呢，是因为 unordered_set 系列容器不仅空间占比大，而且把数值映射到key上都要做 hasd 计算的，计算速度慢。

#### 两个数组的交集
* 求两个数组的交集，其实需要两个 unordered_set, 第一是将其中一个数组去重，遍历另一个数组的元素，若有发现其在第一个 unordered_set 中, 则将其元素加入到另一个 unordered_set 中。
* set 系列用于哈希值少，比较分撒，跨度很大的场景，也就是数组不适合的场景，都用 set 来做。
* 这里的有一些语法需要注意：set 与 vector 之间的转换, map 与 vector 之间的转换。
```C++
// set 与 vector 之间的互相转换
#include <vector>
#include <unordered_set>

int main() {
    std::vector<int> vec {1, 2, 3, 4};
    std::unordered_set<int> set(vec.begin(), vec.end());
    vec = std::vector<int>(set.begin(), set.end());
}
```

```C++
// map 转换为 vector
#include <string>
#include <map>
#include <vector>
#include <algorithm>

int main()
{
    std::map<std::string, int> map;
    std::vector<int> vec;

    map["one"] = 1;
    map["two"] = 2;
    map["three"] = 3;
    map["four"] = 4;
    map["five"] = 5;

    // 用于对范围内的元素进行变换，并将结果存储到另一个范围。
    std::transform( 
        map.begin(), 
        map.end(),
        std::back_inserter(vec),        // 需要使用back_inserter，它会自动为vector分配空间
        [](auto &kv){ return kv.first;} // 返回输入迭代器的key，需要c++14
    );
}

// 注意这种写法, 上面的 back_inserter 是未分配空间，能够自动扩充, 接下来的是分配了空间
#include <algorithm>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec1 {1, 2, 3, 4, 5};
    std::vector<int> vec2 {1, 2, 3, 4, 5};
    std::vector<int> result(vec1.size());

    std::transform(vec1.begin(), vec1.end(), vec2.begin(), result.begin(), [](int x, int y) { return x + y; });

    for (int i : result) {
        std::cout << i << " ";
    }

    return 0;
}
```

#### 快乐数
* 要注意审题，题目中说了，如果其是快乐数，最后的各个位平方之和为 1，否则会无限循环。注意这个无限循环，其意味着如果不是快乐数，各个位平方之和的结果会循环出现。
* 这道题目就只能用 set 系列来做，因为不满足有限、尽可能连续的数组应用规则。
* 给一个正整数，取各个位上的数字的方法：
```C++
// 这里加了对负数挑选其各个位的方法，从低位到高位，就是很好拿出来呢
std::vector<int> getNum(int n)
{
    // 这里得到的结果是从低位到高位
    std::vector<int> result;
    bool isNegative = n < 0;
    n = std::abs(n);
    
    while(n){
        result.push_back(n % 10);
        n /= 10;
    }

    // 如果是负数，处理特殊情况
    if (isNegative && !result.empty()) {
        result.back() *= -1; // 把最后一位变成负数
    }

    return result;
}
```

#### 两数之和
* 首先应该想到的是，用一个循环遍历每个元素，能够知道其中一个数是多少，但是需要查找数组中是否有另一个数, 所以想到了用哈希表。
* 但是不能直接把数组转换为 set，因为这样可能会有重复元素，未说明数组中元素不能重复。
* 所以可以先逐个遍历，将遍历过的数字加入到集合中，即使有重复也不怕，因为是选两个元素，当前遍历到的就是第一个。
* 所以使用 std::unordered_map 即可，注意这里需要 key 存储数组值，value 存储索引下标（因为要找到这两个数的索引下标）。

#### 三数之和
* 通常来说，返回数组元素的内容的组合，而不是数组下标的组合，一般都是需要先排序的，然后再来做。
* 这道题目让返回的是元素内容，我们想到用双指针的方法。
* 首先对数据进行排序(从小到大)，然后利用一个 for 循环从左向右遍历，确定一个元素i（这个元素一定出现在数组中）
* left = i+1, right=size()-1, 如果 A[i] + A[left] + A[right] < target, 那就 left++; 如果 > , 就 right--; 不断重复循环，直到 left >= right
* 以上是遍历所有的组合，但是返回的结果要去重。对于 i 这个最小值的去重，`if(i>0 && nums[i]==nums[i-1]) continue;`。对于 left 和 right 的去重，是在每次添加完元素之后，`while (right > left && nums[right] == nums[right - 1]) right--;` 和 ` while (right > left && nums[left] == nums[left + 1]) left++;`;
* 还有一种利用 set 容器来去重的操作，代码如下所示
```C++
/*
    set::set 是基于红黑树（或其他平衡二叉搜索树）实现的有序容器。
    它使用元素类型的 < 运算符（或者自定义的比较函数）来维护元素的有序性和唯一性。
    因此，只要元素类型支持 < 运算符，std::set 就可以直接使用。
    std::vector<> 和 std::array<> 均重载了 operator< 就是逐个比较其中元素的大小

    是基于哈希表实现的无序容器。它依赖于元素类型的哈希函数和相等比较函数来确保元素的唯一性和查找的高效性。
    标准库中并没有为 std::vector<int> 提供默认的哈希函数和相等比较函数，因此我们需要自己提供这些函数。
*/
#include <iostream>
#include <vector>
#include <array>
#include <algorithm>
#include <set>
#include <unordered_set>

int main() {
    // 示例数据
    std::vector<std::array<int, 3>> vec = {
        {1, 2, 3},
        {4, 5, 6},
        {1, 2, 3}, // 重复元素
        {3, 2, 1}, // 重复元素
        {7, 8, 9},
        {4, 4, 6}  // 重复元素
    };

    // 使用 std::set 去重
    std::set<std::array<int, 3>> s(vec.begin(), vec.end());
    vec.assign(s.begin(), s.end());

    // 输出去重后的结果
    for (const auto& arr : vec) {
        std::cout << "{" << arr[0] << ", " << arr[1] << ", " << arr[2] << "}\n";
    }

    return 0;
}
```
* 两数之和那道题目，要求返回的是索引，所以不能直接使用这种双指针的方法，不然第一步一排序，就直接乱套了。

#### 四数之和
* 这道题目其实和三数之和是同一个道理，本来应该是 O(n^4) 的时间复杂度，通过双指针的方法降低成为了 O(n^3)
* 三数之和是先利用一个 for 循环确定一个最小的值，而四数之和就是先利用两个 for 循环来确定两个最小的值，然后再利用 left 和 right 进行一个遍历
* 注意这里也有去重的操作，与三数之和是一样的道理。i 是去重后的 i, k=i+1 开始，在对 k 去重。然后 left = k+1, right = size()-1;
* 总结一下的话，从三数之和和四数之和来看，每个索引都要去重，只不过 left 和 right 是在结果加入完之后再去重。

#### 四数相加
* 注意题目问的是有多少个？我们只需要统计次数就可以了。
* 将四个数组分成两组，A 和 B 一组，先计算这两个数组能够相加出来的和，并存入 map 中, key 是相加的和, value 是出现的次数。
* 再遍历 B 和 C，寻找其相加的和，如果能在 上一个 map 中找到相反数，就加一次 value 的值。
* 这样两两归类，就将时间复杂度从 O(n^4) 降低到了 O(n^2)。

### 字符串
#### 字符串反转
* 对于字符串反转、数组反转，其实写法都是一样的，都是用双指针的方法，`left=0, right=size()-1`, 循环条件是 `while(left<right)`, 注意交换写法，直接使用 `std::swap()`
* 对于链表的反转，也是利用双指针的方法，不过是直接改变指针的指向。
* 但是要注意的是, 也要善于使用库函数, std::reverse 反转，能够方便地实现某个区间内的反转。

#### 替换数字
* 其实这道题目是一个向数组或者字符串中插入多个元素的问题，是使用双指针的方法。
* 先用一个指针指向扩容前的最后一个元素，再用一个指针指向扩容后的最后一个元素，指向扩容后的元素的指针不到起始位置的时候，不停止。
* 先判断指向扩容前的指针指向的索引或者元素内容，然后向扩容后的位置插入特定的元素。
* 这道题目与删除数组/串中指定的值（多次删除）有很多相似之处，那个也是双指针的做法。

#### 反转字符串里的单词
* 实现 `"  hello world!  " -> "world! hello"`, 去除字符串中多余的空格, 利用双指针的方法，去除字符串中的某个元素（慢指针指向空格时候, 快指针必须指向字符串才能往后更新）。
* 然后将整个字符串反转，直接使用库函数即可；最后再将其中的每个单词进行反转(一次for遍历，利用一个变量记录上次单词开始的位置)
* 注意这种先整体大反转，再局部分块小反转的方法，是非常有用的。
* 右循环移动字符串/数组，将字符串/数组整体向右循环移动 n 位。其实整体思路就是将其分成两个部分，后n位和起始到后n位之前的部分。先将整个字符串颠倒，然后再将这两个位置分别颠倒。

#### KMP 算法
* KMP的经典思想就是：当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。
* 其实除了字符串，数组也是一样的。抽象来说，就是对一个主串，寻找第一次出现模式串的位置。
* next 数组就是一个前缀表，前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。
* 时间复杂度 O(n+m), 空间复杂度 O(m)[因为需要保存needle的前缀表]

```C++
void getNext(std::vector<int>& next, const std::string& s){
    int j=-1;
    next[0] = j;

    for(int i=1; i<s.size(); ++i)
    {
        while(j>=0 && s[j+1]!=s[i])
        {
            j=next[j];
        }

        if(s[j+1]==s[i])  // 只有相等的时候才 ++j
        {
            ++j;
        }

        next[i]=j;  // 要保证每个 next 都有值
    }
}

int getIdx(const std::string& str, const std::string& needle)
{
    if(needle.size()==0) return 0;  // 搜索空字符串时, 返回 0, 特殊规定

    std::vector<int> next(needle.size());  // 核心是 next 数组, j 是最长相等前后缀的值, next[j] 是前 j 个字符中最长相等前后缀的值
    getNext(next, needle);

    int j=-1;  // 因为下面比较了 needle [j+1] 和 str[i], 所以 j 是从 -1 开始的
    for(int i=0; i<str.size(); ++i)
    {
        while(j>=0 && needle[j+1]!=str[i])
        {
            j=next[j];
        }

        // j 在这里也是统计着最长相等前后缀的值 
        if (needle[j + 1] == str[i]) {  // 只有相等才 ++
            ++j;
        }

        if(j==needle.size()-1)
        {
            return i-j;
        }
    }

    return -1;
}
```

#### 重复的子字符串
* 这道题目其实没有什么技巧，只是能不能想到这种方法。
* 将两个子串s拼接到一起(t=s+s)，然后删除掉t的第一个元素和删除掉最后一个元素。在剩余串中寻找是否还能出现 s，若能出现则是由重复的串构成的。
* 这里的 KMP 算法就直接使用 `find` 函数就可以了。
* 要是数组的话，可以先转为字符串在进行操作，或者直接使用 KMP 算法进行寻找。

### 栈与队列
* 栈是先进后出，C++中是 `std::stack<>`, 队列是先进先出，C++ 中是 `std::queue<>`。栈和队列在 C++ 中都是容器适配器，其底层容器是 `std::queue<>`, `std::vector<>` 或 `std::list<>` (其实 C++ 中的栈和队列要求的是底层容器能够提供那些函数，如果自定义的类包含这些函数，那也可以使用自定义的)。
* 栈里面的元素在内存中是连续分布的么？
    - 陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。
    - 陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。

#### 用栈实现队列
* 要用两个栈来实现队列，一个输入栈，一个输出栈。输入栈负责队列的 push 操作，输出栈负责队列的 pop 操作。
* 在队列 push 的时候，将数据都放入到输入栈就行；在队列 pop 的时候，如果输出栈为空，就把输入栈数据全部导入进输出栈，再从输出栈弹出数据。
* 如果输入栈和输出栈都为空的时候，队列就为空。

#### 用单向队列实现栈
* 使用两个单向队列，一个做为输入队列，一个做为输出队列，其实是没有作用的，因为并不会颠倒元素顺序。
* 其实只需要使用一个单向队列就能实现栈，在栈 push 的时候，直接将元素 push 进队列就行; 在栈 pop 的时候, 将除了最后一个元素全都 pop 出去，然后依次加入到队列末尾。此时再 pop，就得到了最后加入的元素。
* 当单向队列为空的时候，栈就空了。

#### 括号匹配(栈)
* 由于栈的结构，使其非常适合做`对称匹配`的问题。
* 依次编列输入的括号字符串，如果当前的字符是`(`，`[`等左括号，就将其需要匹配的右括号`)`, `]`加入栈中；如果当前字符是右括号`]`，`)`, 就判断栈是否为空，如果为空就匹配失败，如果不为空，但是栈顶元素不等于当前字符也匹配失败。遍历完所有字符后，如果栈不为空，仍然匹配失败。

#### 删除字符串中重复的元素(栈)
* 这个也是匹配问题，通过遍历当前元素来前一个元素是否与当前遍历的元素相同。
* 这里如果用栈做为中间存储的话，最后要记得颠倒下字符元素，最简洁的方法是直接用存储字符串的结果来当作栈使用。

#### 逆波兰表达式(栈)
* 逆波兰表达式是一种后缀表达式(运算符写在后面), 比如平时正常的中缀表达式是 (1+2)*(3+4) 变成后缀表达式后为 `12+34+*`, 逆波兰表达式其实是用后序遍历的方式把二叉树序列化。
* 逆波兰表达式的优点是，去掉括号表达式无歧义，使用用栈操作运算（遇到数字则入栈，遇到运算符去除栈顶两个元素进行计算，并将结果压入栈中）。
* 逆波兰表达式求值的整体思路是：遇到数字则入栈; 遇到运算符去除栈顶两个元素进行计算，并将结果压入栈中; 最终表达式是值就是栈里的最后一个元素。

#### 滑动窗口最大值(单调队列)
* 其实就是要求，能够找到最大的元素，而且还能够删除指定的元素。
* 如果使用优先队列(大顶堆) `priority_queue`，能够每次找到最大的元素，但是并不能删除指定的元素。
* 所以这里可以使用自建的单调队列，也可以使用 `multiset`，这个是满足这个性质的，而且元素能够重复。
* 注意这里实现滑动窗口的代码逻辑。逐一遍历数组中的元素，当加入前 k-1 个时候，只有向 `multiset` 中插入的操作；当插入完前k个元素后，以后每次都要将 set 中的最大值保存到数组中（利用 `rbegin()`, 因为默认是从小到达排序）, 从第 k+1 个元素开始，就每次都是删除一个指定元素(i-k)，添加一个指定元素。
* 这里也给我们提了个醒，对于变化的元素进行排序的时候，可以使用红黑树的 `set` 来帮助我们。

#### 前 k 个高频元素(优先队列)
* 这里主要分成三个步骤，先用 map 统计每个元素出现的频率；然后依据频率进行排序；最后找出前 K 个最高频的元素。
* 因为 C++ 中的 map 通常只能依据 key 的值来进行排序，所以这里利用优先队列(小顶堆)来进行排序，即队列元素小于k的时候，就一直将map元素往里扔。当时队列元素等于k的时候，每次压入元素前，先把最小的给剔除。
* 最后将优先队列中的k个元素逐个pop()出去，然后依序加入到 vector 中，就是从大到小的结果。
```C++
// 小顶堆
class mycomparison {
public:
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};

// 对频率排序
// 定义一个小顶堆，大小为k
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
```
* 其实还有其他方法实现对 map 中元素的排序；首先仍然是先使用 map 统计各个词出现的频率；然后定义一个 set, 自定义排序顺序，将 map 中的元素都加入到 set 中。

#### 单调栈
