#### 一面
1. 访存优化是如何体现的呢？
2. 手撕题目：存在正整数 m,n,k。从 0 开始，每次操作可以 +1/m 或者 +1/k, 最多多少次可以等于 1/n。
3. 如何计算 warp 占用率呢？
4. 存在正整数 m,n,k。从 0 开始，每次操作可以 +1/m 或者 + 1/k, 最少多少次操作可以等于 1/n。
    - 这道题目可以先转变为 如果从 0 开始，每次操作可以增加 nk 或者 mn, 最少多少次操作可以等于 mk。
```C++
#include <iostream>
#include <vector>
#include <algorithm>

int minOperations(int m, int k, int n) {
    int step1 = n*k;
    int step2 = m*n;
    if(step1>step2) std::swap(step1, step2);  // 交换下 step1 和 step2, 使得 step1 是小的步符
    int target = m*k;
    std::vector<int> dp(target+1, INT32_MAX);  // dp[i] 表示最少多少次操作可以等于 i
    if(target < step1) return -1;
    dp[step1] = 1;
    for(int i=step1+1; i<target+1; ++i)
    {
        dp[i] = std::min(dp[i-step1], dp[i-step2])+1;
    }

    return dp[target]==INT32_MAX ? -1 : dp[target];
}

int main() {
    int m, k, n;
    std::cout << "请输入 m, k 和 n 的值: ";
    std::cin >> m >> k >> n;

    int result = minOperations(m, k, n);
    if (result == -1) {
        std::cout << "不能构成" << std::endl;
    } else {
        std::cout << "最少操作次数为: " << result << std::endl;
    }

    return 0;
}
```

#### 二面
1. 一道 kernel 题目, Softmax: half -> float -> half, {M, N}, N ~ (256, 1024)?

