## C++ 基础知识点

1. 生产消费者模型?
* 生产消费者模型通过容器/缓存区域(阻塞队列), 解决生产消费者的强耦合问题。生产者和消费者之间通过阻塞队列来进行通信。生产者产生数据直接扔进缓冲区中，消费者每次取时上锁，避免冲突，取完解锁处理业务逻辑。具体情况，视于队列空和满的条件决定。
```C++
#include <thread>
#include <queue>
#include <iostream>
#include <mutex>
#include <condition_variable>

//生产者消费者模式
template <typename T>
class Queue
{
public:
    //  指定队列能够存放的最大元素个数
    Queue(int maxn = 20) : thread_maxnum(maxn) {}

    //生产者
    void Push(const T &val)
    {
        // 将锁视为一种资源, 通过 unique_lock 来看管
        std::unique_lock<std::mutex> locker(m_mtx);
        m_cond_Full.wait(locker, [this]() { return mq.size() < thread_maxnum; });  // 使用条件变量等待队列有空间
        
        mq.push(val);
        std::cout << "Pushed: " << val << "\n";

        m_cond_Empty.notify_all();      //解锁互斥量，唤醒消费者线程
    }

    //消费者
    T Pop()
    {
        std::unique_lock<std::mutex> locker(m_mtx);
        m_cond_Empty.wait(locker, [this]() { return !mq.empty(); });  // 使用条件变量等待队列不为空

        T val = mq.front();
        mq.pop();
        std::cout << "Popped: " << val << "\n";

        m_cond_Full.notify_all(); //解锁互斥量，唤醒生产者线程

        return val;
    }

private:
    std::queue<T> mq;                     // 容器/缓冲区解决生产者消费者的强耦合问题
    std::mutex m_mtx;                     // 互斥锁, 一个共享资源对应一个锁
    int thread_maxnum;                    // 缓冲区最大数量
    std::condition_variable m_cond_Empty; // 条件变量，对应消费者线程
    std::condition_variable m_cond_Full;  // 条件变量，对应生产者线程
};

void producer(Queue<int> *q)
{
    for (int i = 0; i < 1000; i++)
    {
        q->Push(i);
    }
}

void consumer(Queue<int> *q)
{
    for (int i = 0; i < 500; i++)
    {
        auto t = q->Pop();
    }
}

int main()
{
    Queue<int> q(20);
    std::thread t1(producer, &q);
    std::thread t2(consumer, &q);

    t1.join();
    t2.join();

    return 0;
}
```
2. 程序链接和装入的步骤是什么样的呢？
* 链接: 编译之后, 每个文件都是单独的一个模块, 都是分开的逻辑地址, 链接的目的就是 `分开的逻辑地址->统一的逻辑地址(整合)`。链接的方法分为以下几种:
    - 静态链接: 装入之前, 把所有的目标模块整合成一个目标模块, 以后不再拆开。
    - 装入时动态链接: 每个模块都装入, 边装入边链接, 便于修改和更新。
    - 运行时动态链接: 运行时用到的模块, 调入内存并连接到装入模块。能够加快程序装入过程, 节省存储空间。
* 装入: 装入的目的, 其实就是实现逻辑地址到物理地址的转换(因为要真正的装入内存中了)。
    - 绝对装入: 编译时就转换, 产生绝对的物理地址, 后序不再修改。
    - 可重定位装入(静态重定位): 
        - 装入内存时才转换为物理地址; 必须一整个作业一起装入, 并分配连续的内存空间; 运行期间在内存中不能移动。
    - 动态运行时装入(动态重定位):
        - 装入内存后不立即转换地址, 而是推迟到程序执行时(用到了那一块再转换); 可以只装入部分代码就能运行; 便于程序段共享; 可以分配到不连续的存储区, 可以发生移动。
3. 动态库和静态库的区别？[原文](https://blog.csdn.net/sjp11/article/details/121086026#:~:text=%E7%A8%8B%E5%BA%8F%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%BD%93%E7%A8%8B%E5%BA%8F)
* 函数库是一个非常重要的东西, 很多程序都会互相使用彼此的库来使用其特殊的功能。函数库本质是一堆非包含 `main函数` 的 .c 文件, 通过编译后形成的相对应的 .o 文件, 然后将所有的代码打包到一个文件下, 这个文件就是库, 也就是说库函数是一堆 .o 文件的集合。当我们使用该库的某些功能时, 我们只需要将我们的程序和库中的某些.o文件链接起来就可以了。库函数依据使用类型分为`静态库(libxxx.a)` 和 `动态库(libxxx.so)`。
    - 静态库: 在编译链接的时候, 直接将库中的所有二进制的代码整合到程序中(其实是被映射到了程序地址空间的`代码区`上, 每个进程都映射一份, 是彼此独立的), 所以编译成功的可执行文件是可以独立运行的, 不需要依赖任何外界的库。
    - 动态库: 程序中用到了动态库中的函数, 在编译的时候, 程序中只会保留一个指针。动态函数中的文件并没有将所有的代码整合到程序中, 而是在该程序运行时, 用到该库函数的内容, 才通过指针去读取函数库来使用, 由于程序中只包含动态库的指针, 所以该程序的文件会比较小。链接动态库的可执行程序不能够独立运行, 它的运行必须依赖动态库, 所以动态库必须存在才行。当程序在运行时需要动态库的功能时，程序会去某个路径下去读取动态库，所以动态库不能够随便的删除或者移动，它将会影响很多个程序。程序运行时需要动态库时候, 系统会将动态库加载到内存中, 映射到程序地址空间的`共享区`中, 也就是说一个动态库在内存中可以被若干个进程给共享着，当有很多个进程的时候，只需要有一份动态库的代码就可以维持这些进程的运行，所以动态库是可以节省内存空间的。当进程需要的时候就去动态库里面找就可以了。所以当动态库从内存中移除的时候，可能会有很多个进程给挂掉。对于共享库中的代码, 多个进程可以共享这部分代码。对于共享库中的数据, 有些数据是只读的, 可以像共享代码一样共享这些只读数据。也有一些数据是可写的, 对于可写的数据, 操作系统通常会采用写时复制(copy-on-Write)技术。当一个进程试图修改共享数据时，操作系统会先为该进程创建一个副本，然后该进程在副本上进行修改，而其他进程仍然继续访问原来的共享数据。这样既保证了数据的共享性，又保证了每个进程对数据修改的独立性。
* 静态库和动态库的优缺点是:
    - 静态库:
        - 缺点: 编译形成的可执行程序大, 当有多个静态库连接的可执行程序在内存中运行时, 也会消耗大量的内存空间。
        - 优点: 可以独立运行, 不需要读取其他库的文件内容就能运行。
    - 动态库:
        - 缺点: 不能够独立运行, 必须依赖动态库, 如果没有动态库时，则相关的所有的动态链接的可执行程序都不能运行。
        - 优点: 编译链接形成的可执行程序小, 当有多个动态库链接形成的可执行程序在内存中运行时，可以节省大量的内存空间，因为只需要加载一份动态库的内容，就能维持相关的可执行程序。
* 静态库和动态库的生成方法:
    * 生成静态库的方法:
    ```Shell
    $ gcc -c add.c sub.c              // 将会生成 add.o 和 sub.o
    $ ar -rc libmymath.a add.o sub.o  // 将 add.o 和 sub.o 打包形成静态库
    ```
    * 使用静态库的方法:
    ```Shell
    // 其中 -I 使编译器到指定的路径下寻找头文件  -L 指明编译器到./mathlib/lib的路径下寻找有add实现的库  -l 指明要链接哪一个库（注意-l后面加的是库的名称，而不是库的扩展名）
    $ gcc test.c -I ./mathlib/include   -L ./mathlib/lib    -l mymath
    ```
    ![](../fig/生成静态库.png)
    * 生成动态库的方法:
    ```Shell
    // 生成 .o 文件, -fpic选项作用于编译阶段, 告诉编译器产生与位置无关代码, 则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行(共享库被加载进去, 在内存中的位置是不固定的)。
    $ gcc -c -fpic add.c
    $ gcc -c -fpic sub.c
    // 将 .o 文件打包, 形成动态库
    $ gcc -shared -o libmymath.so add.o sub.o
    ```
    * 使用动态库的方法:
    ```Shell
    $ gcc test.c -I ./mathlib/include   -L ./mathlib/lib    -l mymath
    // 此时编译是没有问题的, 但是要是想运行起来, 还要告诉操作系统动态库的位置(静态库都包含进去啦, 所以没有这个问题)。`LD_LIBRARY_PATH` 是系统搜索动态库的路径, 操作系统会默认到该环境变量下的路径查找动态库。
    ```
    ![](../fig/动态库.png)

4. 同一个进程的多个线程堆栈共享情况？
* 各个线程私有的: 栈, 寄存器, 状态寄存器(Flags), 程序计数器(PC)。
* 各个线程共享的: 堆, 数据段(全局变量和静态变量), 代码段, 内核空间。
* 同一区域的各变量按声明的顺序在内存的中依次由低到高分配空间。
* 父进程和子进程与两个无亲缘关系的线程没有本质的区别, 基本上是一样的。

5. 多个进程的通信方式有哪些？
* 进程通信的用处:
    - 数据传输: 一个进程需要将它的数据发送给另一个进程。
    - 共享数据: 多个进程间要操作共享数据, 一个进程对共享数据的修改, 别的进程应该能够立刻看到。
    - 通知事件: 一个进行需要向另一个或者另一组进程发送消息, 通知他们发生了某种事件。
    - 进程控制: 一个进程希望控制另一个进程的运行。
* 进程通信的方式有那些:
    - 管道: 匿名管道和命名管道。匿名管道可用于具有父进程和子进程之间的通信。 命名管道克服了匿名管道的没有名字的限制, 除了匿名管道具有的功能外, 它还允许无亲缘关系进程间的通信。
        - 详细原理: 管道是一种在两个进程间进行单向通信的机制。传输数据是单向的, 所以是半双工管道。数据只能由一个进程流向另一个进程（其中一个读管道，一个写管道）；如果要进行全双工通信，需要建立两个管道。管道是由内核管理的一个缓冲区, 管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。缓冲区通常被设计为环形的数据结构, 以便管道可以被循环利用。当两个进程都终结的时候，管道也自动消失。
        - 环形队列的优点(需要频繁的进行入队、出队操作且需要高效的利用内存空间的场景):
            - 节省内存空间: 普通队列在执行出队操作时, 队头会向队尾方向移动, 导致前面的空间无法再利用。环形队列可以再利用这一段内存空间。
            - 避免移动元素: 普通队列中每次出队时, 都能需要移动大量的数据, 而环形队列只需要更新队头和队尾的指针，效率更高。
    - 消息队列: 进程可以向队列中添加消息，其它的进程则可以读取队列中的消息。
    - 共享内存: 多个进程可以访问同一块内存空间。
    - socket通信: 可以同一台计算机间进程的通信, 也可以用于不同计算之间进程的通信。
* `管道`, `消息队列` 都是在内核开辟一块缓冲区, 进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走。这种通信方式涉及到了数据的 copy 和 `用户态->内核态` 的转变。
* 共享机制是通过 `映射函数mmap` 把要共享的文件内容映射到进程的虚拟内存上, 通过对这段内存的读取和修改实现对文件的读取和修改。共享内存分配在用户空间中, 所以进程可以以访问的方式对文件进行访问, 不需要其他系统调用去操作。优点如下:
    - 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率(可以利用缓存机制)。
    - 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉(不需要用户空间和内核空间的切换)。
    - 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。
```C++
// $ ipcs  -m                    查看系统的共享内存都有那些
// $ ipcrm -m 共享内存的 shmid   手动删除共享内存
#include <stdio.h>
#include <string.h>
#include <unistd.h>

// 这两个库是共享内存的专用库
#include <sys/ipc.h>
#include <sys/shm.h>

int main()
{
    int shmid; // 共享内存标识符

    // 依据键值得到共享内存, 找不到的话则创建，键值为0x5005，共1024字节。
    if ((shmid = shmget((key_t)0x5005, 1024, 0640 | IPC_CREAT)) == -1)
    {
        printf("shmat(0x5005) failed\n");
        return -1;
    }

    char *ptext = 0; // 用于指向共享内存的指针

    // 将共享内存连接到当前进程的地址空间，由ptext指针指向它
    // 第二个参数是定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址
    // 第三个参数是是一组标志位，通常为0
    ptext = (char *)shmat(shmid, 0, 0);

    // 操作本程序的ptext指针，就是操作共享内存
    printf("写入前：%s\n", ptext);
    sprintf(ptext, "本程序的进程号是：%d", getpid());
    printf("写入后：%s\n", ptext);

    // 把共享内存从当前进程中分离, 相当于shmat函数的反操作
    shmdt(ptext);

    // 删除共享内存, 后两个参数都是默认值
    // if (shmctl(shmid, IPC_RMID, 0) == -1)
    // {
    //     printf("shmctl(0x5005) failed\n");
    //     return -1;
    // }
}
```
6. 设计模式之观察者模式
* 观察者模式 (发布-订阅模式) 属于行为型模式, 定义了一种一对多的依赖关系, 让多个观察者对象同时监听同一个主题对象, 当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。观察者模式依赖两个模块:
    - Subject(主题): 被观察的对象, 它可以维护一组观察者, 当主题本身发生改变时就会通知观察者。
    - Observer(观察者): 观察主题的对象, 当 `被观察` 的主题发生变化时, 观察者就会得到通知并执行相应的处理。
* 观察者实现方式(有4个组成部分):
    - `主题Subject`: 一般会定义成一个接口, 提供方法用于注册、删除和通知观察者。
    - `具体主题ConcreteSubject`: 主题的具体实现, 维护一个观察者列表和状态, 具体观察者的注册、删除和通知方法, 当状态发生改变时, 通知所有的观察者。
    - `观察者Observer`: 观察者也需要实现一个接口, 包含更更新方法, 在接受到主题通知时执行对应的操作。
    - `具体观察者ConcreteObserver`: 观察者更新方法的具体实现。
    ![](../fig/观察者模式.png)
```C++
#include <iostream>
#include <vector>
#include <algorithm> 

// 观察者接口, 定义更新方法接口, 抽象类, 所以要有虚析构函数
class Observer {
public:
    virtual void update(int hour) = 0;
    virtual ~Observer() = default; // 添加虚析构函数
};

// 主题接口, 定义注册观察者、移除观察者、通知观察者的方法, 抽象类, 要有虚析构函数
class Subject {
public:
    virtual void registerObserver(Observer* observer) = 0;
    virtual void removeObserver(Observer* observer) = 0;
    virtual void notifyObservers() = 0;
    virtual ~Subject() = default; // 添加虚析构函数
};

// 具体主题实现
class Clock : public Subject {
private:
    // 观察者列表
    std::vector<Observer*> observers;
    // 维护一个状态, 状态变化通知观察者
    int hour;

public:
    Clock() : hour(0) {}

    // 注册观察者
    void registerObserver(Observer* observer) override {
        observers.push_back(observer);
    }

    // 移除观察者
    void removeObserver(Observer* observer) override {
        auto it = std::find(observers.begin(), observers.end(), observer);
        if (it != observers.end()) {
            observers.erase(it);
        }
    }

    // 通知观察者, 就是一个遍历操作
    void notifyObservers() override {
        for (Observer* observer : observers) {
            observer->update(hour);  // 根据状态进行更新
        }
    }

    // 添加获取观察者的函数
    const std::vector<Observer*>& getObservers() const {
        return observers;
    }

    void tick() {
        hour = (hour + 1) % 24; // 模拟时间的推移
        notifyObservers();
    }
};

// 具体观察者实现
class Student : public Observer {
private:
    std::string name;

public:
    Student(const std::string& name) : name(name) {}

    void update(int hour) override {
        std::cout << name << " " << hour << std::endl;
    }
};

int main() {
    // 读取学生数量
    int N;
    std::cin >> N;

    // 创建时钟
    Clock clock;

    // 注册学生观察者
    for (int i = 0; i < N; i++) {
        std::string studentName;
        std::cin >> studentName;
        clock.registerObserver(new Student(studentName));
    }

    // 读取时钟更新次数
    int updates;
    std::cin >> updates;

    // 模拟时钟每隔一个小时更新一次
    for (int i = 0; i < updates; i++) {
        clock.tick();
    }

    // 释放动态分配的观察者对象
    for (Observer* observer : clock.getObservers()) {
        delete observer;
    }

    return 0;
}
```
* 观察者模式特别适用于一个对象的状态变化会影响到其他对象，并且希望这些对象在状态变化时能够自动更新的情况。图形用户界面中，按钮、滑动条等组件的状态变化可能需要通知其他组件更新，这使得观察者模式被广泛应用于GUI框架。在分布式系统中，观察者模式可以用于实现节点之间的消息通知机制，节点的状态变化将通知其他相关节点。

7. 死锁相关的问题？
* 死锁是两个或者两个以上的线程在执行的过程中去争夺同一组共享资源导致的互相等待的一个现象。在没有外部的干预的情况下, 线程会一直处于阻塞状态, 无法往下去执行。
![](../fig/死锁解法.png)
* 死锁的四个必备条件:
    - 资源互斥: 共享资源 x 和 y 只能被一个线程所占有(都要用菜刀, 但是菜刀只有一个)。
    - 持续占有: 线程 t1 获得了 x, 再等待 y 的时候不释放共享资源 x(我拿着菜刀, 菜没做完, 不交出去)。
    - 不可抢占: 其他线程不能强行去抢占线程 t1 占用的资源(我拿着菜刀的时候，不允许别人抢走我手上的菜刀)。
    - 循环等待: 线程 t2 等待线程 t1 占有的资源, 线程 t1 等待线程 t2 占有的资源(我切菜需要菜刀和菜板，我拿着菜刀，你拿着菜板，我没有菜板用，你没有刀用)。
* 必须同时具备上述四个条件能是死锁，其中任何一条不满足都无法构成死锁。解决死锁也很简单——破坏掉其中任意一个条件即可。
* 解决死锁的方法:
    - 破坏资源互斥: 提供多个共享资源(这个一般没有办法避免)。
    - 破坏持续占用: 线程等待一段时候后, 释放手上的资源。
    - 破坏不可抢占: 在当前线程等待资源时，允许其他现成抢占当前线程持有的资源。
    - 破坏循环等待: 给资源编号, 如果有A，B，C资源，需要按照顺序持有资源。必须持有A才能持有B，必须持有B才能持有C。

8. Cache 的映射原理？
* Cache 与主存的区别是什么？
    - 主存是 DRAM(动态随机存储器), 存储元的结构由一个电容和一个晶体管组成。由于电容会逐渐漏电，因此需要定期刷新来保持数据。DRAM 的结构更简单，因此密度更高，存储容量更大，但访问速度较慢。
    - Cache 是 SRAM(静态随机存储器), 存储元的结构是`双稳态触发器`, 由6个晶体管组成。SRAM 是一种高性能的存储器，其数据存储不需要刷新周期(每个存储元都有一个VDD供电)，速度极快。
* Cache 与主存的映射方式?
    - 全相联映射: 允许主存中的任何一个Cache行(块)可以映射到缓存中的任何一个块。存中的每个块都与一个有效的标记（tag）进行比较，以确定是否命中。
        - 优点: 主存的任何块都可以放到缓存的任意位置, 避免缓存冲突问题, 缓存利用率高。
        - 缺点: 比较时间长, 因为要依据 tag 逐一的查找cache中是否有对应的主存数据, 比较的位数也多。
    - 直接映射: 每个主存块只能映射到缓存中的一个特定的位置。
        - 优点: 查找时间短, 只需要比较很少的标志位, 不要查找每个缓存行。
        - 缺点: 当多个主存块映射到同一个缓存块时，会频繁发生替换操作。某些缓存块可能频繁被替换，而其他块可能很少被利用，缓存空间的利用率不高。
    - 组相联映射: 介于全相联映射和直接映射之间的一种折中方案, 缓存分成若干个组, 每组包含若干个块。主存块可以映射到特定组中的任何一块。
        - 优点: 较少的冲突缺失的发生, 主存块在一定范围内选择缓存位置, 提升了缓存的利用率。
![](../fig/Cache原理.png)

9. 进程和线程的区别？
* 本质区别: 进程是资源分配的基本单位, 线程是 CPU 调度的基本单位。进程是包含线程的, 一个进程可以由一个或者多个线程组成。
* 其余区别: 
    - 资源占用: 每个进程都有自己独立的地址空间和资源, 同一进程内的线程共享进程的资源。
    - 信息通信: 进程之间相互独立, 彼此不共享内存, 进程通信(IPC)可以通过管道、消息队列、共享内存来实现。同一进程内线程共享进程的所有资源, 能直接访问相同的内存空间, 通信更高的高效。
    - 并发性(切换效率): 进程间切换开销较大(需要在内存管理上, 保存和恢复更多的状态), 线程间切换信息较小。
* 每个进程都有一个 PCB, PCB 中包含的属性有 PID, 内存指针, 文件描述符, 状态, 优先级, 记账信息, 上下文信息:
    - PID: 进程标识符, 进程的身份证号, 不允许重复出现。
    - 内存指针: 描述一个进程都能使用哪些内存资源(指定了进程使用内存资源的范围)。
    - 文件描述符表: 描述进程占用的资源及一些属性。
    - 状态: 描述进程的状态, 运行态、就绪态、阻塞态。
    - 优先级: 优先级高的进程会优先进入CPU进行执行。
    - 记账信息: 对每一个进程占据了多少CPU时间的统计, 根据这个统计结果来进一步的调整调度的策略。
    - 上下文信息: 当进程进入 CPU 执行后被调度走时，会将当前处理的数据放在上下文中，当下一次重新被调度回来时在通过读取上下文信息进行继续执行。

10. 页面置换算法都有那些？
* 页面置换算法是操作系统内存管理中，用于决定在内存不足时，应将哪一个页面替换出内存，以便为新页面腾出空间。
    - 先进先出(FIFO): 按照页面进入内存的顺序进行置换，最早进入内存的页面最先被置换。缺点是: 无法根据页面使用的实际情况进行优化，可能会将频繁使用的页面置换掉，导致性能下降。
    - 最近最久未使用(LRU): 将最近最久未被使用的页面置换出内存。假设如果一个页面最近没有被访问过，那么它在未来也不大可能会被访问。性能优于 FIFO, 但是需要计数器来跟踪页面的使用时间。
    - 时钟置换算法(Clock Algorithm): 为每个页面设置一个访问位, 再将内存中的页面都通过链接指针连接成一个循环队列。当某页被访问时, 其访问为被置为1(指针不移动的)。当要淘汰一个页面时, 只需检查页面的访问位。如果是 0, 就选择该页换出,将新加入的页的访问位置为1, 如果是 1, 将它置为0, 暂不换出, 继续检查下一个页面。