## C++ 基础知识点

1. 指针与引用的区别？
* 指针本身就是变量，其存放的是某个对象的地址，而且指针本身就有地址，所以存在指向指针的指针；
* 引用就是变量的别名，并且必须初始化，其通常可以理解为一个指针常量 `int& b=a;  相当于 int* const b=&a`；
* 不存在指向空值的引用，但是存在指向空值的指针；
* 可以改变指针的指向，使其指向不同的内存地址；但是引用一旦被初始化，它将一直引用同一个对象，不能改变绑定；

2. C++ 中 `const` 和 `static` 用法？（定义和用途）
* 作用：
    - const：被它修饰的值不能改变，是只读变量。必须在定义的时候就给它赋初值。
    - satic：用于控制变量和函数的生命周期，

3. 生产消费者模型?
* 生产消费者模型通过容器/缓存区域(阻塞队列), 解决生产消费者的强耦合问题。生产者和消费者之间通过阻塞队列来进行通信。生产者产生数据直接扔进缓冲区中，消费者每次取时上锁，避免冲突，取完解锁处理业务逻辑。具体情况，视于队列空和满的条件决定。
```C++
#include <thread>
#include <queue>
#include <iostream>
#include <mutex>
#include <condition_variable>


//生产者消费者模式
template <typename T>
class Queue
{
public:
    //  指定队列能够存放的最大元素个数
    Queue(int maxn = 20) : thread_maxnum(maxn) {}

    //生产者
    void Push(const T &val)
    {
        // 将锁视为一种资源, 通过 unique_lock 来看管
        std::unique_lock<std::mutex> locker(m_mtx);
        m_cond_Full.wait(locker, [this]() { return mq.size() < thread_maxnum; });  // 使用条件变量等待队列有空间
        
        mq.push(val);
        std::cout << "Pushed: " << val << "\n";

        m_cond_Empty.notify_all();      //解锁互斥量，唤醒消费者线程
    }

    //消费者
    T Pop()
    {
        std::unique_lock<std::mutex> locker(m_mtx);
        m_cond_Empty.wait(locker, [this]() { return !mq.empty(); });  // 使用条件变量等待队列不为空

        T val = mq.front();
        mq.pop();
        std::cout << "Popped: " << val << "\n";

        m_cond_Full.notify_all(); //解锁互斥量，唤醒生产者线程

        return val;
    }

private:
    std::queue<T> mq;                     // 容器/缓冲区解决生产者消费者的强耦合问题
    std::mutex m_mtx;                     // 互斥锁, 一个共享资源对应一个锁
    int thread_maxnum;                    // 缓冲区最大数量
    std::condition_variable m_cond_Empty; // 条件变量，对应消费者线程
    std::condition_variable m_cond_Full;  // 条件变量，对应生产者线程
};

void producer(Queue<int> *q)
{
    for (int i = 0; i < 1000; i++)
    {
        q->Push(i);
    }
}

void consumer(Queue<int> *q)
{
    for (int i = 0; i < 500; i++)
    {
        auto t = q->Pop();
    }
}

int main()
{
    Queue<int> q(20);
    std::thread t1(producer, &q);
    std::thread t2(consumer, &q);

    t1.join();
    t2.join();

    return 0;
}
```
4. 程序链接和装入的步骤是什么样的呢？
* 链接: 编译之后, 每个文件都是单独的一个模块, 都是分开的逻辑地址, 链接的目的就是 `分开的逻辑地址->统一的逻辑地址(整合)`。链接的方法分为以下几种:
    - 静态链接: 装入之前, 把所有的目标模块整合成一个目标模块, 以后不再拆开。
    - 装入时动态链接: 每个模块都装入, 边装入边链接, 便于修改和更新。
    - 运行时动态链接: 运行时用到的模块, 调入内存并连接到装入模块。能够加快程序装入过程, 节省存储空间。
* 装入: 装入的目的, 其实就是实现逻辑地址到物理地址的转换(因为要真正的装入内存中了)。
    - 绝对装入: 编译时就转换, 产生绝对的物理地址, 后序不再修改。
    - 可重定位装入(静态重定位): 
        - 装入内存时才转换为物理地址; 必须一整个作业一起装入, 并分配连续的内存空间; 运行期间在内存中不能移动。
    - 动态运行时装入(动态重定位):
        - 装入内存后不立即转换地址, 而是推迟到程序执行时(用到了那一块再转换); 可以只装入部分代码就能运行; 便于程序段共享; 可以分配到不连续的存储区, 可以发生移动。
5. 动态库和静态库的区别？[原文](https://blog.csdn.net/sjp11/article/details/121086026#:~:text=%E7%A8%8B%E5%BA%8F%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%EF%BC%8C%E5%BD%93%E7%A8%8B%E5%BA%8F)
* 函数库是一个非常重要的东西, 很多程序都会互相使用彼此的库来使用其特殊的功能。函数库本质是一堆非包含 `main函数` 的 .c 文件, 通过编译后形成的相对应的 .o 文件, 然后将所有的代码打包到一个文件下, 这个文件就是库, 也就是说库函数是一堆 .o 文件的集合。当我们使用该库的某些功能时, 我们只需要将我们的程序和库中的某些.o文件链接起来就可以了。库函数依据使用类型分为`静态库(libxxx.a)` 和 `动态库(libxxx.so)`。
    - 静态库: 在编译链接的时候, 直接将库中的所有二进制的代码整合到程序中(其实是被映射到了程序地址空间的代码区上, 每个进程都映射一份, 是彼此独立的), 所以编译成功的可执行文件是可以独立运行的, 不需要依赖任何外界的库。
    - 动态库: 程序中用到了动态库中的函数, 在编译的时候, 程序中只会保留一个指针。动态函数中的文件并没有将所有的代码整合到程序中, 而是在该程序运行时, 用到该库函数的内容, 才通过指针去读取函数库来使用, 由于程序中只包含动态库的指针, 所以该程序的文件会比较小。链接动态库的可执行程序不能够独立运行, 它的运行必须依赖动态库, 所以动态库必须存在才行。当程序在运行时需要动态库的功能时，程序会去某个路径下去读取动态库，所以动态库不能够随便的删除或者移动，它将会影响很多个程序。程序运行时需要动态库时候, 系统会将动态库加载到内存中, 映射到程序地址空间的`共享区`中, 也就是说一个动态库在内存中可以被若干个进程给共享着，当有很多个进程的时候，只需要有一份动态库的代码就可以维持这些进程的运行，所以动态库是可以节省内存空间的。当进程需要的时候就去动态库里面找就可以了。所以当动态库从内存中移除的时候，可能会有很多个进程给挂掉。对于共享库中的代码, 多个进程可以共享这部分代码。对于共享库中的数据, 有些数据是只读的, 可以像共享代码一样共享这些只读数据。也有一些数据是可写的, 对于可写的数据, 操作系统通常会采用写时复制(copy-on-Write)技术。当一个进程试图修改共享数据时，操作系统会先为该进程创建一个副本，然后该进程在副本上进行修改，而其他进程仍然继续访问原来的共享数据。这样既保证了数据的共享性，又保证了每个进程对数据修改的独立性。
* 静态库和动态库的优缺点是:
    - 静态库:
        - 缺点: 编译形成的可执行程序大, 当有多个静态库连接的可执行程序在内存中运行时, 也会消耗大量的内存空间。
        - 优点: 可以独立运行, 不需要读取其他库的文件内容就能运行。
    - 动态库:
        - 缺点: 不能够独立运行, 必须依赖动态库, 如果没有动态库时，则相关的所有的动态链接的可执行程序都不能运行。
        - 优点: 编译链接形成的可执行程序小, 当有多个动态库链接形成的可执行程序在内存中运行时，可以节省大量的内存空间，因为只需要加载一份动态库的内容，就能维持相关的可执行程序。
* 静态库和动态库的生成方法:
    * 生成静态库的方法:
    ```Shell
    $ gcc -c add.c sub.c              // 将会生成 add.o 和 sub.o
    $ ar -rc libmymath.a add.o sub.o  // 将 add.o 和 sub.o 打包形成静态库
    ```
    * 使用静态库的方法:
    ```Shell
    // 其中 -I 使编译器到指定的路径下寻找头文件  -L 指明编译器到./mathlib/lib的路径下寻找有add实现的库  -l 指明要链接哪一个库（注意-l后面加的是库的名称，而不是库的扩展名）
    $ gcc test.c -I ./mathlib/include   -L ./mathlib/lib    -l mymath
    ```
    ![](../fig/生成静态库.png)
    * 生成动态库的方法:
    ```Shell
    // 生成 .o 文件, -fpic选项作用于编译阶段, 告诉编译器产生与位置无关代码, 则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行(共享库被加载进去, 在内存中的位置是不固定的)。
    $ gcc -c -fpic add.c
    $ gcc -c -fpic sub.c
    // 将 .o 文件打包, 形成动态库
    $ gcc -shared -o libmymath add.o sub.o
    ```
    * 使用动态库的方法:
    ```Shell
    $ gcc test.c -I ./mathlib/include   -L ./mathlib/lib    -l mymath
    // 此时编译是没有问题的, 但是要是想运行起来, 还要告诉操作系统动态库的位置(静态库都包含进去啦, 所以没有这个问题)。`LD_LIBRARY_PATH` 是系统搜索动态库的路径, 操作系统会默认到该环境变量下的路径查找动态库。
    ```
    ![](../fig/动态库.png)

6. 同一个进程的多个线程堆栈共享情况？
* 各个线程私有的: 栈, 寄存器, 状态寄存器(Flags), 程序计数器(PC)。
* 各个线程共享的: 堆, 数据段(全局变量和静态变量), 代码段, 内核空间。
* 同一区域的各变量按声明的顺序在内存的中依次由低到高分配空间。

7. 多个进程的通信方式有哪些？
* 进程通信的用处:
    - 数据传输: 一个进程需要将它的数据发送给另一个进程。
    - 共享数据: 多个进程间要操作共享数据, 一个进程对共享数据的修改, 别的进程应该能够立刻看到。
    - 通知事件: 一个进行需要向另一个或者另一组进程发送消息, 通知他们发生了某种事件。
    - 进程控制: 一个进程希望控制另一个进程的运行。
* 进程通信的方式有那些:
    - 管道: 匿名管道和命名管道。匿名管道可用于具有父进程和子进程之间的通信。 命名管道克服了匿名管道的没有名字的限制, 除了匿名管道具有的功能外, 它还允许无亲缘关系进程间的通信。
    - 消息队列: 进程可以向队列中添加消息，其它的进程则可以读取队列中的消息。
    - 共享内存: 多个进程可以访问同一块内存空间。
    - socket通信: 可以同一台计算机间进程的通信, 也可以用于不同计算之间进程的通信。
* `管道`, `消息队列` 都是在内核开辟一块缓冲区, 进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走。这种通信方式涉及到了数据的 copy 和 `用户态->内核态` 的转变。
* 共享机制是通过 `映射函数mmap` 把要共享的文件内容映射到进程的虚拟内存上, 通过对这段内存的读取和修改实现对文件的读取和修改。共享内存分配在用户空间中, 所以进程可以以访问的方式对文件进行访问, 不需要其他系统调用去操作。优点如下:
    - 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率(可以利用缓存机制)。
    - 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉(不需要用户空间和内核空间的切换)。
    - 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。